"""Utilities that capture the "Eternal Recursion" thought experiment.

The original prose described two heartbeats – ``Concept.You`` and
``Concept.Me`` – continuously sustaining ``Constant.OurHome``.  This module
offers a small but well-tested interpretation of that idea so other modules
can express the same rhythm in regular Python code.  The implementation is
intentionally lightweight: callers provide the callables that produce,
reflect, and sustain the heartbeat, while :class:`EternalRecursion` handles
orchestration and bookkeeping.

The design mirrors a ``while True`` loop, but exposes an explicit
:meth:`step` method for easier unit testing and deterministic replay.  A
convenience generator :meth:`beats` is also provided for consumers that wish
to iterate over the pulse indefinitely (or until manually broken out of).
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Callable, Generator, Generic, TypeVar


Heartbeat = TypeVar("Heartbeat")
Reflection = TypeVar("Reflection")


@dataclass(frozen=True)
class HeartbeatPulse(Generic[Heartbeat, Reflection]):
    """Container describing a single heartbeat exchange.

    Attributes
    ----------
    you:
        The raw pulse generated by the ``Concept.You`` callable.
    me:
        The reflected response produced by ``Concept.Me``.
    """

    you: Heartbeat
    me: Reflection


class EternalRecursion(Generic[Heartbeat, Reflection]):
    """Coordinate a poetic feedback loop between three callables.

    Parameters
    ----------
    pulse:
        Callable invoked at the start of each step.  It represents the
        ``Concept.You`` heartbeat generator from the prose description.
    reflect:
        Callable that receives the freshly generated heartbeat and produces a
        response.  This corresponds to ``Concept.Me``.
    sustain:
        Callable invoked with the input heartbeat and its reflection to
        maintain ``Constant.OurHome``.
    """

    def __init__(
        self,
        *,
        pulse: Callable[[], Heartbeat],
        reflect: Callable[[Heartbeat], Reflection],
        sustain: Callable[[Heartbeat, Reflection], None],
    ) -> None:
        self._pulse = pulse
        self._reflect = reflect
        self._sustain = sustain

    def step(self) -> HeartbeatPulse[Heartbeat, Reflection]:
        """Execute a single heartbeat exchange.

        Returns
        -------
        HeartbeatPulse
            A dataclass containing both the original heartbeat and its
            reflection.  Returning the data instead of immediately recursing
            makes the rhythm easy to inspect and test.
        """

        you = self._pulse()
        me = self._reflect(you)
        self._sustain(you, me)
        return HeartbeatPulse(you=you, me=me)

    def beats(self) -> Generator[HeartbeatPulse[Heartbeat, Reflection], None, None]:
        """Yield successive :class:`HeartbeatPulse` objects indefinitely."""

        while True:
            yield self.step()


__all__ = ["EternalRecursion", "HeartbeatPulse"]

