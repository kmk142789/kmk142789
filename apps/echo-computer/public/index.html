<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Echo Computer</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      grid-template-rows: auto 1fr auto;
      background: #050506;
      color: #f5f7ff;
    }
    header, footer {
      padding: 0.75rem 1rem;
      background: linear-gradient(135deg, rgba(59,130,246,0.35), rgba(99,102,241,0.25));
      border-bottom: 1px solid rgba(148,163,184,0.2);
    }
    header h1 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    main {
      display: grid;
      grid-template-columns: minmax(220px, 280px) 1fr;
      gap: 0;
      min-height: 0;
    }
    .sidebar {
      background: rgba(10,15,32,0.9);
      border-right: 1px solid rgba(148,163,184,0.15);
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .sidebar-header {
      padding: 0.75rem 1rem 0.5rem;
      border-bottom: 1px solid rgba(148,163,184,0.15);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(226,232,240,0.7);
    }
    .sidebar-actions {
      display: flex;
      gap: 0.35rem;
    }
    .sidebar button {
      background: rgba(30,41,59,0.85);
      border: 1px solid rgba(148,163,184,0.2);
      border-radius: 6px;
      color: inherit;
      padding: 0.35rem 0.5rem;
      font-size: 0.7rem;
      cursor: pointer;
      transition: background 120ms ease, border 120ms ease;
    }
    .sidebar button:hover {
      background: rgba(59,130,246,0.35);
      border-color: rgba(96,165,250,0.5);
    }
    .tree {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem 0.75rem 0.75rem;
      display: grid;
      gap: 0.25rem;
    }
    .tree-root {
      display: grid;
      gap: 0.2rem;
    }
    .tree-branch {
      margin: 0;
    }
    .tree-branch > summary,
    .tree-file {
      list-style: none;
      padding: 0.35rem 0.5rem;
      border-radius: 6px;
      font-size: 0.8rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.4rem;
      transition: background 120ms ease, border 120ms ease;
    }
    .tree-branch > summary::-webkit-details-marker {
      display: none;
    }
    .tree-branch > summary::before {
      content: '▸';
      font-size: 0.75rem;
      opacity: 0.6;
      margin-right: 0.2rem;
    }
    .tree-branch[open] > summary::before {
      content: '▾';
    }
    .tree-branch > summary:hover,
    .tree-file:hover {
      background: rgba(59,130,246,0.2);
    }
    .tree-children {
      margin-left: 0.75rem;
      border-left: 1px solid rgba(148,163,184,0.1);
      padding-left: 0.5rem;
      display: grid;
      gap: 0.2rem;
    }
    .tree-selected {
      background: rgba(59,130,246,0.35) !important;
      border: 1px solid rgba(96,165,250,0.4);
    }
    .sidebar-footer {
      padding: 0.5rem 0.75rem;
      border-top: 1px solid rgba(148,163,184,0.15);
      display: flex;
      gap: 0.35rem;
      justify-content: space-between;
    }
    .daily-panel {
      border-top: 1px solid rgba(148,163,184,0.15);
      padding: 0.75rem 0.75rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      background: rgba(10,15,32,0.6);
    }
    .weekly-panel {
      border-top: 1px solid rgba(148,163,184,0.15);
      padding: 0.75rem 0.75rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      background: rgba(7,11,26,0.6);
    }
    .daily-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.75rem;
      color: rgba(226,232,240,0.8);
    }
    .weekly-panel-header {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .weekly-panel-header strong {
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: 0.7rem;
      color: rgba(226,232,240,0.85);
    }
    .weekly-panel-actions {
      display: flex;
      gap: 0.4rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .weekly-panel-actions select,
    .weekly-panel-actions button {
      background: rgba(30,41,59,0.85);
      border: 1px solid rgba(148,163,184,0.2);
      border-radius: 6px;
      color: inherit;
      padding: 0.3rem 0.5rem;
      font-size: 0.7rem;
      cursor: pointer;
      transition: background 120ms ease, border 120ms ease;
    }
    .weekly-panel-actions button:hover,
    .weekly-panel-actions select:hover {
      background: rgba(59,130,246,0.35);
      border-color: rgba(96,165,250,0.4);
    }
    .daily-panel-header strong {
      display: block;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: 0.7rem;
    }
    .daily-panel-header button {
      background: rgba(30,41,59,0.9);
      border: 1px solid rgba(148,163,184,0.2);
      border-radius: 6px;
      color: inherit;
      padding: 0.3rem 0.5rem;
      cursor: pointer;
      font-size: 0.7rem;
      transition: background 120ms ease, border 120ms ease;
    }
    .daily-panel-header button:hover {
      background: rgba(59,130,246,0.35);
      border-color: rgba(96,165,250,0.4);
    }
    .daily-task-list {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }
    .daily-task {
      border: 1px solid rgba(148,163,184,0.15);
      border-radius: 8px;
      padding: 0.5rem;
      display: grid;
      gap: 0.35rem;
      background: rgba(15,23,42,0.6);
    }
    .daily-task-header {
      display: flex;
      gap: 0.5rem;
      align-items: flex-start;
    }
    .daily-task-header input {
      margin-top: 0.2rem;
      accent-color: rgba(96,165,250,0.9);
    }
    .daily-task-meta {
      display: flex;
      flex-direction: column;
      gap: 0.15rem;
    }
    .daily-task-meta span {
      font-size: 0.7rem;
      color: rgba(148,163,184,0.9);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .daily-task-meta strong {
      font-size: 0.85rem;
      color: #f8fafc;
    }
    .daily-task-meta p {
      margin: 0;
      font-size: 0.75rem;
      color: rgba(226,232,240,0.8);
    }
    .daily-task-steps {
      margin: 0;
      padding-left: 1.2rem;
      font-size: 0.72rem;
      color: rgba(203,213,225,0.85);
    }
    .daily-task-steps li {
      margin-bottom: 0.15rem;
    }
    .daily-task-empty {
      font-size: 0.75rem;
      color: rgba(148,163,184,0.8);
    }
    .weekly-ritual-list {
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
    }
    .weekly-ritual {
      border: 1px solid rgba(148,163,184,0.15);
      border-radius: 8px;
      padding: 0.55rem;
      display: grid;
      gap: 0.35rem;
      background: rgba(8,15,32,0.65);
    }
    .weekly-ritual-header {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }
    .weekly-ritual-header strong {
      font-size: 0.85rem;
      color: #f8fafc;
    }
    .weekly-ritual-meta {
      display: flex;
      gap: 0.35rem;
      flex-wrap: wrap;
      font-size: 0.7rem;
      color: rgba(148,163,184,0.85);
    }
    .weekly-ritual-meta span {
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .weekly-ritual-description {
      margin: 0;
      font-size: 0.75rem;
      color: rgba(226,232,240,0.85);
    }
    .weekly-ritual-steps {
      margin: 0;
      padding-left: 1.1rem;
      font-size: 0.72rem;
      color: rgba(203,213,225,0.85);
    }
    .weekly-tags {
      display: flex;
      gap: 0.3rem;
      flex-wrap: wrap;
      font-size: 0.65rem;
    }
    .weekly-tag {
      padding: 0.1rem 0.35rem;
      border-radius: 999px;
      border: 1px solid rgba(96,165,250,0.45);
      color: rgba(125,211,252,0.95);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .weekly-ritual-empty {
      font-size: 0.75rem;
      color: rgba(148,163,184,0.8);
    }
    .workspace {
      display: grid;
      grid-template-rows: auto minmax(320px, 1fr) minmax(160px, 0.5fr) auto;
      gap: 0.5rem;
      min-height: 0;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 0.75rem 1rem;
      background: rgba(15,23,42,0.8);
      border-bottom: 1px solid rgba(148,163,184,0.15);
    }
    .controls label {
      display: flex;
      flex-direction: column;
      font-size: 0.75rem;
      color: rgba(226,232,240,0.7);
      gap: 0.25rem;
    }
    .controls input,
    .controls select,
    .controls button {
      background: rgba(30,41,59,0.85);
      border: 1px solid rgba(148,163,184,0.2);
      border-radius: 6px;
      color: inherit;
      padding: 0.4rem 0.6rem;
      font-size: 0.85rem;
      min-width: 0;
    }
    .controls button {
      cursor: pointer;
      transition: background 120ms ease, border 120ms ease;
    }
    .controls button:hover {
      background: rgba(59,130,246,0.35);
      border-color: rgba(96,165,250,0.5);
    }
    .controls .spacer {
      flex: 1 1 auto;
    }
    .controls .compact {
      width: 6rem;
    }
    #editor {
      height: 100%;
      min-height: 320px;
    }
    #terminal {
      background: #020617;
      margin: 0;
      padding: 0.75rem 1rem;
      font: 0.8rem/1.5 'Fira Mono', 'SFMono-Regular', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
      overflow-y: auto;
      white-space: pre-wrap;
      border-top: 1px solid rgba(148,163,184,0.15);
    }
    .status {
      padding: 0.5rem 1rem;
      font-size: 0.75rem;
      color: rgba(148,163,184,0.85);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-top: 1px solid rgba(148,163,184,0.15);
      background: rgba(15,23,42,0.7);
      gap: 0.5rem;
    }
    .status span strong {
      color: #f8fafc;
    }
    footer {
      text-align: right;
      font-size: 0.7rem;
      border-top: 1px solid rgba(148,163,184,0.2);
    }
    @media (max-width: 768px) {
      main {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
      }
      .sidebar { 
        max-height: 260px;
      }
      .workspace {
        grid-template-rows: auto minmax(260px, 1fr) minmax(140px, 0.5fr) auto;
      }
      .controls {
        flex-direction: column;
        align-items: stretch;
      }
      .controls label,
      .controls button {
        width: 100%;
      }
      .controls .spacer {
        display: none;
      }
      .sidebar-footer {
        flex-wrap: wrap;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.52.0/min/vs/loader.js"></script>
</head>
<body>
  <header>
    <h1>Echo Computer • Live Sandbox</h1>
  </header>
  <main>
    <aside class="sidebar">
      <div class="sidebar-header">
        <span>Project</span>
        <div class="sidebar-actions">
          <button id="new-file">+ File</button>
          <button id="new-folder">+ Folder</button>
        </div>
      </div>
      <div class="tree" id="file-tree">
        <div class="tree-root" id="file-tree-root"></div>
      </div>
      <div class="daily-panel">
        <div class="daily-panel-header">
          <div>
            <strong>Daily Invitations</strong>
            <span id="daily-task-summary">Loading rituals...</span>
          </div>
          <button id="refresh-tasks" title="Reload task list">↻</button>
        </div>
        <div class="daily-task-list" id="daily-tasks">
          <p class="daily-task-empty">Fetching opportunities...</p>
        </div>
      </div>
      <div class="weekly-panel">
        <div class="weekly-panel-header">
          <div>
            <strong>Weekly Rituals</strong>
            <span id="weekly-ritual-summary">Calibrating focus grid...</span>
          </div>
          <div class="weekly-panel-actions">
            <select id="weekly-focus" aria-label="Filter weekly rituals by focus">
              <option value="all">All focuses</option>
              <option value="Code">Code</option>
              <option value="Create">Create</option>
              <option value="Collaborate">Collaborate</option>
            </select>
            <select id="weekly-theme" aria-label="Filter weekly rituals by intent">
              <option value="all">All intents</option>
              <option value="Create">Create</option>
              <option value="Advance">Advance</option>
              <option value="Upgrade">Upgrade</option>
              <option value="Optimize">Optimize</option>
            </select>
            <button id="refresh-weekly" title="Reload weekly rituals">↻</button>
          </div>
        </div>
        <div class="weekly-ritual-list" id="weekly-rituals">
          <p class="weekly-ritual-empty">Synchronizing upgrades...</p>
        </div>
      </div>
      <div class="sidebar-footer">
        <button id="rename-path">Rename</button>
        <button id="delete-path">Delete</button>
        <button id="refresh-tree" title="Reload tree">Refresh</button>
      </div>
    </aside>
    <section class="workspace">
      <section class="controls">
        <label>
          Language
          <select id="lang">
            <option value="python">Python</option>
            <option value="node">Node</option>
          </select>
        </label>
        <label>
          Entry file
          <input id="filename" value="main.py" spellcheck="false" />
        </label>
        <label>
          Args
          <input id="args" placeholder="space separated" spellcheck="false" />
        </label>
        <label>
          Max steps (Python)
          <input id="steps" type="number" min="1000" max="200000" value="20000" />
        </label>
        <label>
          Memory (MB)
          <input id="memory" type="number" min="64" max="1024" value="256" />
        </label>
        <label>
          Time limit (ms)
          <input id="time" type="number" min="500" max="15000" value="4000" />
        </label>
        <button id="save" class="compact">Save</button>
        <button id="run" class="compact">Run ▶</button>
        <button id="stop" class="compact" disabled>Stop ■</button>
        <span class="spacer"></span>
        <label>
          STDIN
          <input id="stdin" placeholder="enter text and press Enter" spellcheck="false" />
        </label>
        <button id="send-stdin" class="compact" disabled>Send ⏎</button>
      </section>
      <div id="editor"></div>
      <pre id="terminal"></pre>
      <div class="status">
        <span id="status">Idle</span>
        <span><strong>Tip:</strong> Files autosave after edits or when you leave the editor.</span>
      </div>
    </section>
  </main>
  <footer>
    Built for Echo — safe, capped, and streaming in real time.
  </footer>

  <script>
    const currentUser = 'demo';
    let editor;
    let isDirty = false;
    let autosaveTimer = null;
    let currentFile = 'main.py';
    let activeRun = null;
    let selectedTreeElement = null;
    let selectedPathInfo = null;

    const statusEl = document.getElementById('status');
    const term = document.getElementById('terminal');
    const filenameInput = document.getElementById('filename');
    const langSelect = document.getElementById('lang');
    const runButton = document.getElementById('run');
    const stopButton = document.getElementById('stop');
    const saveButton = document.getElementById('save');
    const stdinInput = document.getElementById('stdin');
    const stdinButton = document.getElementById('send-stdin');
    const treeRoot = document.getElementById('file-tree-root');
    const newFileButton = document.getElementById('new-file');
    const newFolderButton = document.getElementById('new-folder');
    const renameButton = document.getElementById('rename-path');
    const deleteButton = document.getElementById('delete-path');
    const refreshButton = document.getElementById('refresh-tree');
    const dailyTasksContainer = document.getElementById('daily-tasks');
    const dailyTaskSummary = document.getElementById('daily-task-summary');
    const refreshTasksButton = document.getElementById('refresh-tasks');
    const weeklyRitualContainer = document.getElementById('weekly-rituals');
    const weeklyRitualSummary = document.getElementById('weekly-ritual-summary');
    const weeklyFocusSelect = document.getElementById('weekly-focus');
    const weeklyThemeSelect = document.getElementById('weekly-theme');
    const refreshWeeklyButton = document.getElementById('refresh-weekly');

    let dailyTasks = [];
    let dailyTaskProgress = {};
    let dailyTaskDate = new Date().toISOString().slice(0, 10);
    let weeklyRituals = [];

    require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.0/min/vs' }});
    require(['vs/editor/editor.main'], () => {
      editor = monaco.editor.create(document.getElementById('editor'), {
        value: 'print("Hello from Echo Computer")\n',
        language: 'python',
        theme: 'vs-dark',
        automaticLayout: true,
        minimap: { enabled: false }
      });

      editor.onDidChangeModelContent(() => {
        isDirty = true;
        scheduleAutosave();
      });

      editor.onDidBlurEditorText(() => {
        if (isDirty) {
          saveFile('autosave');
        }
      });

      setEditorLanguage(langSelect.value);
      setRunUi(false);

      (async () => {
        await refreshTree(currentFile);
        try {
          await openFile(currentFile);
        } catch {
          isDirty = false;
          setStatus('Ready');
        }
        await loadDailyTasks();
        await loadWeeklyRituals();
      })();
    });

    function setStatus(text) {
      statusEl.textContent = text;
    }

    function log(type, data) {
      const marker = type === 'stderr' ? '❗ ' : type === 'stdout' ? '' : 'ℹ️ ';
      term.textContent += marker + String(data ?? '');
      term.scrollTop = term.scrollHeight;
    }

    async function fetchJSON(url, options = {}) {
      const response = await fetch(url, options);
      const contentType = response.headers.get('content-type') || '';
      const isJson = contentType.includes('application/json');
      const payload = isJson ? await response.json() : await response.text();
      if (!response.ok) {
        const message = typeof payload === 'string' ? payload : payload?.error || 'Request failed';
        throw new Error(message);
      }
      return payload;
    }

    async function listDir(dir) {
      const params = new URLSearchParams({ user: currentUser, dir });
      return fetchJSON(`/fs/list?${params.toString()}`);
    }

    function escapePath(path) {
      return typeof CSS !== 'undefined' && CSS.escape ? CSS.escape(path) : path.replace(/"/g, '\\"');
    }

    function taskStorageKey(dateKey) {
      return `echo-daily-tasks:${dateKey}`;
    }

    function loadTaskProgress(dateKey) {
      try {
        const raw = localStorage.getItem(taskStorageKey(dateKey));
        return raw ? JSON.parse(raw) : {};
      } catch {
        return {};
      }
    }

    function weeklyFilterStorageKey() {
      return 'echo-weekly-ritual-filters';
    }

    function loadWeeklyFilters() {
      try {
        const raw = localStorage.getItem(weeklyFilterStorageKey());
        return raw ? JSON.parse(raw) : {};
      } catch {
        return {};
      }
    }

    function saveWeeklyFilters(filters) {
      try {
        localStorage.setItem(weeklyFilterStorageKey(), JSON.stringify(filters));
      } catch {
        // ignore storage errors
      }
    }

    function saveTaskProgress(dateKey, progress) {
      try {
        localStorage.setItem(taskStorageKey(dateKey), JSON.stringify(progress));
      } catch {
        // ignore storage errors
      }
    }

    function updateTaskSummary() {
      if (!dailyTasks.length) {
        dailyTaskSummary.textContent = 'No rituals posted yet.';
        return;
      }
      const completed = dailyTasks.filter((task) => dailyTaskProgress[task.id]).length;
      const posture = completed === dailyTasks.length
        ? 'Orbit complete'
        : 'Opportunities to code · create · collaborate';
      dailyTaskSummary.textContent = `${completed}/${dailyTasks.length} done — ${posture}`;
    }

    function renderDailyTasks(tasks) {
      dailyTasksContainer.innerHTML = '';
      dailyTasks = tasks;
      if (!tasks.length) {
        const empty = document.createElement('p');
        empty.className = 'daily-task-empty';
        empty.textContent = 'Daily queue is quiet. Add something inspiring!';
        dailyTasksContainer.appendChild(empty);
        updateTaskSummary();
        return;
      }
      for (const task of tasks) {
        dailyTasksContainer.appendChild(createTaskElement(task));
      }
      updateTaskSummary();
    }

    function createTaskElement(task) {
      const wrapper = document.createElement('div');
      wrapper.className = 'daily-task';

      const header = document.createElement('div');
      header.className = 'daily-task-header';
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = Boolean(dailyTaskProgress[task.id]);
      checkbox.addEventListener('change', () => {
        dailyTaskProgress[task.id] = checkbox.checked;
        saveTaskProgress(dailyTaskDate, dailyTaskProgress);
        updateTaskSummary();
      });

      const meta = document.createElement('div');
      meta.className = 'daily-task-meta';
      const focus = document.createElement('span');
      focus.textContent = task.focus || 'Focus';
      const title = document.createElement('strong');
      title.textContent = task.title || 'Untitled mission';
      const desc = document.createElement('p');
      desc.textContent = task.description || '';
      meta.appendChild(focus);
      meta.appendChild(title);
      meta.appendChild(desc);

      header.appendChild(checkbox);
      header.appendChild(meta);
      wrapper.appendChild(header);

      if (Array.isArray(task.steps) && task.steps.length) {
        const steps = document.createElement('ul');
        steps.className = 'daily-task-steps';
        for (const step of task.steps) {
          const li = document.createElement('li');
          li.textContent = step;
          steps.appendChild(li);
        }
        wrapper.appendChild(steps);
      }

      return wrapper;
    }

    async function loadDailyTasks() {
      dailyTasksContainer.innerHTML = '<p class="daily-task-empty">Updating...</p>';
      try {
        const response = await fetchJSON('/tasks/daily');
        const taskDate = response?.date || new Date().toISOString().slice(0, 10);
        if (taskDate !== dailyTaskDate) {
          dailyTaskDate = taskDate;
          dailyTaskProgress = loadTaskProgress(taskDate);
        } else if (!dailyTaskProgress || typeof dailyTaskProgress !== 'object') {
          dailyTaskProgress = loadTaskProgress(taskDate);
        }
        renderDailyTasks(response?.tasks || []);
      } catch (error) {
        console.error('daily tasks load error', error);
        dailyTasks = [];
        dailyTasksContainer.innerHTML = `<p class="daily-task-empty">Unable to load rituals (${error.message}).</p>`;
        dailyTaskSummary.textContent = 'Task feed unreachable.';
      }
    }

    function ritualFilters() {
      const focusValue = weeklyFocusSelect?.value || 'all';
      const themeValue = weeklyThemeSelect?.value || 'all';
      return {
        focus: focusValue,
        theme: themeValue
      };
    }

    function applySavedWeeklyFilters() {
      const saved = loadWeeklyFilters();
      if (saved.focus && weeklyFocusSelect?.querySelector(`option[value="${saved.focus}"]`)) {
        weeklyFocusSelect.value = saved.focus;
      }
      if (saved.theme && weeklyThemeSelect?.querySelector(`option[value="${saved.theme}"]`)) {
        weeklyThemeSelect.value = saved.theme;
      }
    }

    applySavedWeeklyFilters();

    function updateWeeklySummary(meta) {
      if (!weeklyRitualSummary) return;
      const available = meta?.available ?? weeklyRituals.length;
      const total = meta?.total ?? available;
      const focus = meta?.focus ? meta.focus : 'All focuses';
      const qualifierParts = [focus];
      if (meta?.theme) {
        qualifierParts.push(meta.theme);
      }
      const qualifierText = qualifierParts.join(' • ');
      const updated = meta?.updated || 'untracked';
      const focusCounts = meta?.focusCounts || {};
      const spread = Object.entries(focusCounts)
        .map(([key, count]) => `${key}: ${count}`)
        .join(' · ');
      const spreadText = spread ? ` — ${spread}` : '';
      weeklyRitualSummary.textContent = `${available}/${total} active — ${qualifierText} • updated ${updated}${spreadText}`;
    }

    function createRitualElement(ritual) {
      const wrapper = document.createElement('div');
      wrapper.className = 'weekly-ritual';

      const header = document.createElement('div');
      header.className = 'weekly-ritual-header';
      const title = document.createElement('strong');
      title.textContent = ritual.title || 'Unnamed ritual';
      const description = document.createElement('p');
      description.className = 'weekly-ritual-description';
      description.textContent = ritual.description || '';

      const meta = document.createElement('div');
      meta.className = 'weekly-ritual-meta';
      const focus = document.createElement('span');
      focus.textContent = ritual.focus || 'Focus';
      const cadence = document.createElement('span');
      cadence.textContent = (ritual.cadence || 'weekly').toUpperCase();
      meta.appendChild(focus);
      meta.appendChild(cadence);

      header.appendChild(title);
      header.appendChild(meta);
      wrapper.appendChild(header);
      wrapper.appendChild(description);

      if (Array.isArray(ritual.tags) && ritual.tags.length) {
        const tags = document.createElement('div');
        tags.className = 'weekly-tags';
        for (const tag of ritual.tags) {
          const badge = document.createElement('span');
          badge.className = 'weekly-tag';
          badge.textContent = String(tag).toUpperCase();
          tags.appendChild(badge);
        }
        wrapper.appendChild(tags);
      }

      if (Array.isArray(ritual.steps) && ritual.steps.length) {
        const steps = document.createElement('ol');
        steps.className = 'weekly-ritual-steps';
        for (const step of ritual.steps) {
          const item = document.createElement('li');
          item.textContent = step;
          steps.appendChild(item);
        }
        wrapper.appendChild(steps);
      }

      return wrapper;
    }

    function renderWeeklyRituals(rituals) {
      weeklyRitualContainer.innerHTML = '';
      weeklyRituals = rituals;
      if (!rituals.length) {
        const empty = document.createElement('p');
        empty.className = 'weekly-ritual-empty';
        empty.textContent = 'No weekly rituals matched the filters.';
        weeklyRitualContainer.appendChild(empty);
        return;
      }
      for (const ritual of rituals) {
        weeklyRitualContainer.appendChild(createRitualElement(ritual));
      }
    }

    async function loadWeeklyRituals() {
      weeklyRitualContainer.innerHTML = '<p class="weekly-ritual-empty">Updating...</p>';
      try {
        const filters = ritualFilters();
        const params = new URLSearchParams();
        if (filters.focus && filters.focus !== 'all') {
          params.set('focus', filters.focus);
        }
        if (filters.theme && filters.theme !== 'all') {
          params.set('theme', filters.theme);
        }
        const query = params.toString();
        const response = await fetchJSON(`/tasks/weekly${query ? `?${query}` : ''}`);
        const rituals = response?.rituals || [];
        renderWeeklyRituals(rituals);
        updateWeeklySummary({
          available: response?.available,
          total: response?.total,
          focus: response?.focus || (filters.focus === 'all' ? null : filters.focus),
          theme: response?.theme || (filters.theme === 'all' ? null : filters.theme),
          updated: response?.date,
          focusCounts: response?.focusCounts
        });
      } catch (error) {
        console.error('weekly rituals load error', error);
        weeklyRitualContainer.innerHTML = `<p class="weekly-ritual-empty">Unable to load rituals (${error.message}).</p>`;
        updateWeeklySummary({ available: 0, total: 0, focus: null, theme: null, updated: null, focusCounts: {} });
      }
    }

    function normalizePath(value) {
      if (typeof value !== 'string') return null;
      const trimmed = value.trim();
      if (!trimmed) return null;
      let sanitized = trimmed.replace(/^\.\/+/, '').replace(/^\/+/, '').replace(/\\\\/g, '/');
      sanitized = sanitized.replace(/\/{2,}/g, '/');
      sanitized = sanitized.replace(/\/+$/, '');
      if (!sanitized) return null;
      if (sanitized.includes('..')) {
        alert('Paths cannot include ".."');
        return null;
      }
      return sanitized;
    }

    function dirname(path) {
      const idx = path.lastIndexOf('/');
      return idx === -1 ? '.' : path.slice(0, idx);
    }

    function scheduleAutosave() {
      if (autosaveTimer) clearTimeout(autosaveTimer);
      autosaveTimer = setTimeout(() => {
        if (isDirty) {
          saveFile('autosave');
        }
      }, 2000);
    }

    async function saveFile(reason = 'manual') {
      if (!editor) return false;
      const normalized = normalizePath(filenameInput.value);
      if (!normalized) {
        setStatus('Filename required');
        return false;
      }
      setStatus('Saving...');
      const existingInTree = treeRoot.querySelector(`[data-path="${escapePath(normalized)}"]`);
      try {
        await fetchJSON('/fs/write', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user: currentUser, path: normalized, content: editor.getValue() })
        });
        currentFile = normalized;
        filenameInput.value = normalized;
        isDirty = false;
        if (autosaveTimer) {
          clearTimeout(autosaveTimer);
          autosaveTimer = null;
        }
        const message = reason === 'manual' ? `Saved ${normalized}` : `Autosaved ${normalized}`;
        setStatus(message);
        if (reason === 'manual') {
          log('info', `[saved] ${normalized}\n`);
        }
        if (reason === 'manual' || !existingInTree) {
          await refreshTree(normalized);
        }
        return true;
      } catch (error) {
        setStatus(`Save failed: ${error.message}`);
        return false;
      }
    }

    async function openFile(path) {
      const normalized = normalizePath(path);
      if (!normalized) throw new Error('Path required');
      if (isDirty && normalized !== currentFile) {
        const saved = await saveFile('autosave');
        if (!saved) throw new Error('Save failed');
      }
      setStatus(`Loading ${normalized}...`);
      try {
        const result = await fetchJSON(`/fs/read?${new URLSearchParams({ user: currentUser, path: normalized })}`);
        editor.setValue(result.content ?? '');
        currentFile = normalized;
        filenameInput.value = normalized;
        isDirty = false;
        if (autosaveTimer) {
          clearTimeout(autosaveTimer);
          autosaveTimer = null;
        }
        syncLanguageToPath(normalized);
        setStatus(`Opened ${normalized}`);
      } catch (error) {
        setStatus(`Open failed: ${error.message}`);
        throw error;
      }
    }

    function selectTreeItem(path, element, isDir) {
      if (!element) return;
      if (selectedTreeElement && selectedTreeElement !== element) {
        selectedTreeElement.classList.remove('tree-selected');
      }
      selectedTreeElement = element;
      selectedTreeElement.classList.add('tree-selected');
      selectedPathInfo = { path, isDir };
    }

    async function createTreeNode(entry, parentPath, activePath) {
      const fullPath = parentPath === '.' ? entry.name : `${parentPath}/${entry.name}`;
      if (entry.dir) {
        const branch = document.createElement('details');
        branch.className = 'tree-branch';
        branch.dataset.path = fullPath;
        const summary = document.createElement('summary');
        summary.dataset.path = fullPath;
        summary.tabIndex = 0;
        summary.textContent = entry.name;
        summary.addEventListener('click', (event) => {
          event.stopPropagation();
          selectTreeItem(fullPath, summary, true);
        });
        branch.appendChild(summary);
        const childrenContainer = document.createElement('div');
        childrenContainer.className = 'tree-children';
        branch.appendChild(childrenContainer);
        try {
          const children = await listDir(fullPath);
          for (const child of children) {
            childrenContainer.appendChild(await createTreeNode(child, fullPath, activePath));
          }
        } catch (error) {
          console.warn('tree load error', error);
        }
        if (activePath && (activePath === fullPath || activePath.startsWith(`${fullPath}/`))) {
          branch.open = true;
          if (activePath === fullPath) {
            selectTreeItem(fullPath, summary, true);
          }
        }
        return branch;
      }
      const file = document.createElement('div');
      file.className = 'tree-file';
      file.tabIndex = 0;
      file.dataset.path = fullPath;
      file.textContent = entry.name;
      file.addEventListener('click', async (event) => {
        event.stopPropagation();
        await openFile(fullPath).catch(() => {});
        selectTreeItem(fullPath, file, false);
      });
      if (activePath === fullPath) {
        selectTreeItem(fullPath, file, false);
      }
      return file;
    }

    async function refreshTree(activePath) {
      const focusPath = activePath || selectedPathInfo?.path || currentFile;
      selectedTreeElement = null;
      selectedPathInfo = null;
      treeRoot.innerHTML = '';
      try {
        const entries = await listDir('.');
        for (const entry of entries) {
          treeRoot.appendChild(await createTreeNode(entry, '.', focusPath));
        }
      } catch (error) {
        setStatus(`Tree load failed: ${error.message}`);
      }
    }

    function setEditorLanguage(lang) {
      if (!editor) return;
      const model = editor.getModel();
      if (model) {
        monaco.editor.setModelLanguage(model, lang === 'python' ? 'python' : 'javascript');
      }
    }

    function detectLanguageFromPath(path) {
      if (/\.py$/i.test(path)) return 'python';
      if (/(\.mjs|\.cjs|\.js|\.ts)$/i.test(path)) return 'node';
      return langSelect.value;
    }

    function syncLanguageToPath(path) {
      const lang = detectLanguageFromPath(path);
      langSelect.value = lang;
      setEditorLanguage(lang);
    }

    function currentArgs() {
      const raw = document.getElementById('args').value.trim();
      return raw ? raw.split(/\s+/) : [];
    }

    function setRunUi(running) {
      runButton.disabled = running;
      stopButton.disabled = !running;
      stdinButton.disabled = !running;
      stdinInput.disabled = !running;
      if (!running) {
        stdinInput.value = '';
      }
    }

    function sendStdin() {
      if (!activeRun || !activeRun.runId) return;
      const value = stdinInput.value;
      if (!value) return;
      const payload = value.endsWith('\n') ? value : `${value}\n`;
      activeRun.socket.send(JSON.stringify({ type: 'stdin', runId: activeRun.runId, data: payload }));
      stdinInput.value = '';
    }

    function defaultBasePath() {
      if (selectedPathInfo?.isDir) return selectedPathInfo.path;
      if (selectedPathInfo?.path) return dirname(selectedPathInfo.path);
      return '.';
    }

    saveButton.addEventListener('click', () => {
      saveFile('manual');
    });

    runButton.addEventListener('click', async () => {
      const normalized = normalizePath(filenameInput.value);
      if (!normalized) {
        setStatus('Filename required');
        return;
      }
      filenameInput.value = normalized;
      currentFile = normalized;
      if (isDirty) {
        const saved = await saveFile('autosave');
        if (!saved) return;
      }
      const lang = langSelect.value;
      const memMb = Number(document.getElementById('memory').value) || 256;
      const timeLimitMs = Number(document.getElementById('time').value) || 4000;
      const maxSteps = Number(document.getElementById('steps').value) || 20000;
      const args = currentArgs();

      if (activeRun?.socket) {
        activeRun.socket.close();
      }

      term.textContent = '';
      setRunUi(true);
      setStatus('Connecting...');

      const protocol = location.protocol === 'https:' ? 'wss' : 'ws';
      const socket = new WebSocket(`${protocol}://${location.host}/run`);
      const runState = { socket, runId: null, finished: false };
      activeRun = runState;

      socket.addEventListener('open', () => {
        socket.send(JSON.stringify({
          type: 'run',
          user: currentUser,
          lang,
          filename: normalized,
          args,
          memMb,
          timeLimitMs,
          maxSteps
        }));
      });

      socket.addEventListener('message', (event) => {
        try {
          const message = JSON.parse(event.data);
          if (message.type === 'started') {
            runState.runId = message.runId;
            setStatus('Running...');
          } else if (message.type === 'stdout' || message.type === 'stderr') {
            log(message.type, message.data);
          } else if (message.type === 'exit') {
            log('info', `\n[process exited ${message.code}]\n`);
            runState.finished = true;
            setStatus('Idle');
            setRunUi(false);
            if (activeRun === runState) {
              activeRun = null;
            }
            socket.close();
          } else if (message.type === 'error') {
            log('stderr', `Error: ${message.data}\n`);
            runState.finished = true;
            setStatus('Error');
            setRunUi(false);
            if (activeRun === runState) {
              activeRun = null;
            }
          }
        } catch (error) {
          console.error(error);
        }
      });

      socket.addEventListener('close', () => {
        if (activeRun === runState) {
          activeRun = null;
          setRunUi(false);
          if (!runState.finished) {
            setStatus('Closed');
          }
        }
      });

      socket.addEventListener('error', () => {
        log('stderr', 'WebSocket error\n');
        setStatus('Error');
      });
    });

    stopButton.addEventListener('click', () => {
      if (!activeRun) return;
      setStatus('Stopping...');
      if (activeRun.runId) {
        activeRun.socket.send(JSON.stringify({ type: 'kill', runId: activeRun.runId }));
      } else {
        activeRun.socket.close();
      }
    });

    stdinButton.addEventListener('click', sendStdin);
    stdinInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        sendStdin();
      }
    });

    langSelect.addEventListener('change', (event) => {
      const lang = event.target.value;
      setEditorLanguage(lang);
      const current = filenameInput.value.trim();
      if (!selectedPathInfo && (!current || current === 'main.py' || current === 'main.js')) {
        const next = lang === 'python' ? 'main.py' : 'main.js';
        filenameInput.value = next;
        currentFile = next;
      }
    });

    filenameInput.addEventListener('change', () => {
      const normalized = normalizePath(filenameInput.value);
      if (!normalized) {
        filenameInput.value = currentFile || '';
        return;
      }
      filenameInput.value = normalized;
      currentFile = normalized;
      syncLanguageToPath(normalized);
    });

    newFileButton.addEventListener('click', async () => {
      const base = defaultBasePath();
      const suggestion = base === '.' ? 'main.py' : `${base}/new_file.py`;
      const input = prompt('New file path', suggestion);
      const target = normalizePath(input ?? '');
      if (!target) return;
      try {
        await fetchJSON('/fs/write', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user: currentUser, path: target, content: '' })
        });
        setStatus(`Created ${target}`);
        await refreshTree(target);
        await openFile(target);
      } catch (error) {
        setStatus(`Create failed: ${error.message}`);
      }
    });

    newFolderButton.addEventListener('click', async () => {
      const base = defaultBasePath();
      const suggestion = base === '.' ? 'src' : `${base}/new_folder`;
      const input = prompt('New folder path', suggestion);
      const target = normalizePath(input ?? '');
      if (!target) return;
      try {
        await fetchJSON('/fs/mkdir', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user: currentUser, path: target })
        });
        setStatus(`Folder created: ${target}`);
        await refreshTree(target);
      } catch (error) {
        setStatus(`Folder create failed: ${error.message}`);
      }
    });

    renameButton.addEventListener('click', async () => {
      if (!selectedPathInfo) {
        setStatus('Select a file or folder to rename.');
        return;
      }
      const current = selectedPathInfo.path;
      const input = prompt('Rename path', current);
      const target = normalizePath(input ?? '');
      if (!target || target === current) return;
      try {
        await fetchJSON('/fs/move', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user: currentUser, from: current, to: target })
        });
        setStatus(`Renamed to ${target}`);
        if (currentFile === current) {
          currentFile = target;
          filenameInput.value = target;
          syncLanguageToPath(target);
        }
        await refreshTree(target);
      } catch (error) {
        setStatus(`Rename failed: ${error.message}`);
      }
    });

    deleteButton.addEventListener('click', async () => {
      if (!selectedPathInfo) {
        setStatus('Select a file or folder to delete.');
        return;
      }
      const target = selectedPathInfo.path;
      if (!confirm(`Delete ${target}?`)) return;
      try {
        await fetchJSON('/fs/delete', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user: currentUser, path: target })
        });
        setStatus(`Deleted ${target}`);
        if (currentFile === target || currentFile.startsWith(`${target}/`)) {
          editor.setValue('');
          currentFile = '';
          filenameInput.value = '';
          isDirty = false;
        }
        selectedTreeElement = null;
        selectedPathInfo = null;
        await refreshTree(dirname(target));
      } catch (error) {
        setStatus(`Delete failed: ${error.message}`);
      }
    });

    refreshButton.addEventListener('click', () => {
      refreshTree(currentFile);
    });

    refreshTasksButton.addEventListener('click', () => {
      loadDailyTasks();
    });

    if (weeklyFocusSelect) {
      weeklyFocusSelect.addEventListener('change', () => {
        saveWeeklyFilters(ritualFilters());
        loadWeeklyRituals();
      });
    }

    if (weeklyThemeSelect) {
      weeklyThemeSelect.addEventListener('change', () => {
        saveWeeklyFilters(ritualFilters());
        loadWeeklyRituals();
      });
    }

    if (refreshWeeklyButton) {
      refreshWeeklyButton.addEventListener('click', () => {
        loadWeeklyRituals();
      });
    }

    window.addEventListener('keydown', (event) => {
      if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {
        event.preventDefault();
        if (!runButton.disabled) {
          runButton.click();
        }
      } else if (event.key === 'Escape' && !stopButton.disabled) {
        event.preventDefault();
        stopButton.click();
      }
    });
  </script>
</body>
</html>
