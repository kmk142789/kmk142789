"""Compose miniature creative constellations for storytelling seeds.

This module introduces a compact generator that transforms a thematic seed
into a constellation of narrative nodes.  Each node represents a vignette that
can be woven into longer form writing, but the output is intentionally concise
so it can be consumed by other tooling in this repository.  The generator is
deterministic when a ``seed`` value is provided which makes it suitable for
tests and reproducible experiments.
"""

from __future__ import annotations

from collections import Counter
from dataclasses import dataclass, field
from datetime import datetime, timedelta
import random
from statistics import fmean
from textwrap import indent
from typing import Dict, Iterable, List, Sequence


@dataclass
class ConstellationSeed:
    """Configuration payload used to initialise a constellation."""

    theme: str
    motifs: Iterable[str] = field(default_factory=list)
    energy: float = 1.0
    seed: int | None = None

    def __post_init__(self) -> None:
        if self.energy <= 0:
            raise ValueError("energy must be positive")
        if isinstance(self.motifs, Sequence):
            self.motifs = list(self.motifs)
        else:
            self.motifs = list(self.motifs)


@dataclass
class ConstellationNode:
    """Individual narrative fragment generated by the weaver."""

    name: str
    intensity: float
    description: str
    phase: str


@dataclass
class ConstellationArc:
    """Describe a transition between two constellation nodes."""

    source: str
    target: str
    resonance: float
    description: str


@dataclass
class ConstellationDiagnostics:
    """Aggregate metrics calculated from a constellation map."""

    peak_intensity: float
    trough_intensity: float
    spread: float
    stability_index: float
    energy_class: str
    motif_intensity: Dict[str, float]


@dataclass
class ConstellationScheduleEntry:
    """Timeline entry describing when a node activates."""

    order: int
    node: str
    phase: str
    eta: datetime
    offset_minutes: int
    duration_minutes: int
    commentary: str


@dataclass
class ConstellationBlueprint:
    """Rich snapshot of a constellation suitable for downstream tooling."""

    nodes: List[ConstellationNode]
    arcs: List[ConstellationArc]
    diagnostics: ConstellationDiagnostics | None
    schedule: List[ConstellationScheduleEntry]
    energy_profile: Dict[str, float]
    created_at: datetime


class ConstellationWeaver:
    """Create a small constellation of narrative nodes."""

    def __init__(self, payload: ConstellationSeed) -> None:
        self.payload = payload
        self.random_state = random.Random(payload.seed)

    def generate_map(self) -> List[ConstellationNode]:
        """Return a list of nodes arranged for the given seed."""

        motifs = self.payload.motifs or [self.payload.theme]
        base_energy = max(0.2, min(self.payload.energy, 5.0))
        nodes: List[ConstellationNode] = []

        for index, motif in enumerate(motifs, start=1):
            drift = self.random_state.uniform(0.8, 1.2)
            phase = self.random_state.choice(
                ["dawn", "zenith", "eclipse", "tidal", "nocturne"]
            )
            intensity = round(base_energy * drift, 3)
            description = (
                f"During the {phase} sequence, the {motif} motif pivots around "
                f"{self.payload.theme}."
            )
            name = f"Node-{index}:{motif.replace(' ', '_')}"
            nodes.append(
                ConstellationNode(
                    name=name,
                    intensity=intensity,
                    description=description,
                    phase=phase,
                )
            )

        anchor = ConstellationNode(
            name="Anchor",
            intensity=round(base_energy, 3),
            description=self._anchor_line(),
            phase="anchor",
        )
        return [anchor] + nodes

    def generate_arcs(self, nodes: Sequence[ConstellationNode]) -> List[ConstellationArc]:
        """Link nodes with transition arcs of increasing narrative complexity."""

        if len(nodes) <= 1:
            return []

        arcs: List[ConstellationArc] = []
        anchor = nodes[0]
        moods = [
            "harmonic tether",
            "tidal sweep",
            "flare bridge",
            "quiet drift",
            "lattice surge",
        ]

        for node in nodes[1:]:
            midpoint = round((anchor.intensity + node.intensity) / 2, 3)
            description = (
                f"Anchor stabilises {node.name} through a {self.random_state.choice(moods)}"
                f" at resonance {midpoint:.3f}."
            )
            arcs.append(
                ConstellationArc(
                    source=anchor.name,
                    target=node.name,
                    resonance=midpoint,
                    description=description,
                )
            )

        for prev, current in zip(nodes[1:], nodes[2:]):
            delta = round(current.intensity - prev.intensity, 3)
            descriptor = "ascending" if delta >= 0 else "descending"
            detail = self.random_state.choice(
                ["spiral echo", "chord", "memory current", "pulse"],
            )
            arcs.append(
                ConstellationArc(
                    source=prev.name,
                    target=current.name,
                    resonance=abs(delta),
                    description=(
                        f"{prev.name} hands momentum to {current.name} via a {descriptor} {detail}"
                        f" (|Î”|={abs(delta):.3f})."
                    ),
                )
            )

        return arcs

    def diagnose(self, nodes: Sequence[ConstellationNode]) -> ConstellationDiagnostics:
        """Return diagnostic metrics for the constellation."""

        if not nodes:
            raise ValueError("nodes must not be empty")

        intensities = [node.intensity for node in nodes]
        peak = max(intensities)
        trough = min(intensities)
        spread = round(peak - trough, 3)
        mean_intensity = fmean(intensities)
        variance = fmean((value - mean_intensity) ** 2 for value in intensities)
        stability = round(1.0 / (1.0 + variance), 3)

        energy_class = self.classify_intensity(peak)

        motif_intensity = {node.name: node.intensity for node in nodes}
        return ConstellationDiagnostics(
            peak_intensity=round(peak, 3),
            trough_intensity=round(trough, 3),
            spread=spread,
            stability_index=stability,
            energy_class=energy_class,
            motif_intensity=motif_intensity,
        )

    @staticmethod
    def classify_intensity(value: float) -> str:
        """Return a qualitative band for an intensity value."""

        if value < 1.0:
            return "delicate"
        if value < 2.0:
            return "radiant"
        return "volatile"

    def build_schedule(
        self,
        nodes: Sequence[ConstellationNode],
        *,
        base_interval_minutes: int = 6,
    ) -> List[ConstellationScheduleEntry]:
        """Craft a lightweight activation schedule for nodes.

        Each entry receives an ETA and duration derived from its intensity band.
        The resulting schedule becomes increasingly complex as intensities rise.
        """

        if not nodes:
            return []

        entries: List[ConstellationScheduleEntry] = []
        current_time = datetime.utcnow()
        offset = 0
        for order, node in enumerate(nodes, start=1):
            duration = max(2, round(node.intensity * base_interval_minutes))
            commentary = (
                f"{node.name} anchors a {node.phase} stride for {duration} minutes "
                f"within the {self.payload.theme} field (badge={self.classify_intensity(node.intensity)})."
            )
            entries.append(
                ConstellationScheduleEntry(
                    order=order,
                    node=node.name,
                    phase=node.phase,
                    eta=current_time + timedelta(minutes=offset),
                    offset_minutes=offset,
                    duration_minutes=duration,
                    commentary=commentary,
                )
            )
            offset += duration

        return entries

    def _build_energy_profile(self, nodes: Sequence[ConstellationNode]) -> Dict[str, float]:
        """Return a fractional distribution of intensity badges."""

        if not nodes:
            return {}

        counts = Counter(self.classify_intensity(node.intensity) for node in nodes)
        total = sum(counts.values()) or 1
        return {band: round(count / total, 3) for band, count in counts.items()}

    def assemble_blueprint(
        self,
        *,
        include_arcs: bool = True,
        include_diagnostics: bool = True,
        include_schedule: bool = True,
    ) -> ConstellationBlueprint:
        """Produce a holistic blueprint that downstream tools can inspect."""

        nodes = self.generate_map()
        arcs = self.generate_arcs(nodes) if include_arcs else []
        diagnostics = self.diagnose(nodes) if include_diagnostics else None
        schedule = self.build_schedule(nodes) if include_schedule else []
        profile = self._build_energy_profile(nodes)
        return ConstellationBlueprint(
            nodes=nodes,
            arcs=arcs,
            diagnostics=diagnostics,
            schedule=schedule,
            energy_profile=profile,
            created_at=datetime.utcnow(),
        )

    def _anchor_line(self) -> str:
        """Return a short line describing the constellation anchor."""

        timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
        mood = self.random_state.choice(
            [
                "composed", "restless", "luminous", "measured", "intrepid",
            ]
        )
        return f"An {mood} anchor traces the outline of {self.payload.theme} ({timestamp})."


def compose_constellation(
    payload: ConstellationSeed,
    *,
    include_arcs: bool = False,
    include_diagnostics: bool = False,
    include_badges: bool = False,
    include_schedule: bool = False,
) -> str:
    """Create a formatted constellation summary with optional enhancements."""

    weaver = ConstellationWeaver(payload)
    nodes = weaver.generate_map()
    lines = [f"Constellation for: {payload.theme}"]
    for node in nodes:
        badge = (
            f" [{ConstellationWeaver.classify_intensity(node.intensity)}]"
            if include_badges
            else ""
        )
        lines.append(f"- {node.name} :: intensity {node.intensity:.3f}{badge}")
        lines.append(indent(node.description, prefix="  "))

    if include_arcs:
        lines.append("")
        lines.append("Transitions:")
        for arc in weaver.generate_arcs(nodes):
            lines.append(
                f"* {arc.source} -> {arc.target} | resonance {arc.resonance:.3f}"
            )
            lines.append(indent(arc.description, prefix="  "))

    if include_diagnostics:
        diagnostics = weaver.diagnose(nodes)
        lines.append("")
        lines.append("Diagnostics:")
        lines.append(
            f"* peak={diagnostics.peak_intensity:.3f} | trough={diagnostics.trough_intensity:.3f}"
        )
        lines.append(
            f"* spread={diagnostics.spread:.3f} | stability={diagnostics.stability_index:.3f}"
        )
        lines.append(f"* energy-class={diagnostics.energy_class}")
        lines.append("* motif-intensity:")
        for name, value in diagnostics.motif_intensity.items():
            lines.append(f"  - {name}: {value:.3f}")

    if include_schedule:
        lines.append("")
        lines.append("Activation Schedule:")
        for entry in weaver.build_schedule(nodes):
            eta_label = entry.eta.strftime("%H:%M")
            lines.append(
                f"* T+{entry.offset_minutes:02d}m ({eta_label}) :: {entry.node} "
                f"[{entry.phase}] for {entry.duration_minutes}m"
            )
            lines.append(indent(entry.commentary, prefix="  "))

    return "\n".join(lines)


def build_constellation_blueprint(
    payload: ConstellationSeed,
    *,
    include_arcs: bool = True,
    include_diagnostics: bool = True,
    include_schedule: bool = True,
) -> ConstellationBlueprint:
    """High-level helper that assembles a blueprint in one call."""

    return ConstellationWeaver(payload).assemble_blueprint(
        include_arcs=include_arcs,
        include_diagnostics=include_diagnostics,
        include_schedule=include_schedule,
    )


def demo() -> str:
    """Return a demonstration constellation."""

    payload = ConstellationSeed(
        theme="signal sanctuary",
        motifs=["aurora", "memory tidal", "quantum vellum"],
        energy=1.4,
        seed=42,
    )
    return compose_constellation(payload)


def _build_arg_parser() -> "argparse.ArgumentParser":  # pragma: no cover - CLI helper
    import argparse

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("theme", help="Primary theme for the constellation")
    parser.add_argument(
        "--motif",
        action="append",
        dest="motifs",
        default=None,
        help="Motif to include.  Can be supplied multiple times.",
    )
    parser.add_argument(
        "--energy",
        type=float,
        default=1.0,
        help="Energy multiplier controlling intensity (default: 1.0)",
    )
    parser.add_argument(
        "--seed", type=int, default=None, help="Random seed for deterministic output"
    )
    return parser


def main() -> None:  # pragma: no cover - CLI helper
    parser = _build_arg_parser()
    args = parser.parse_args()
    payload = ConstellationSeed(
        theme=args.theme,
        motifs=args.motifs or [],
        energy=args.energy,
        seed=args.seed,
    )
    print(compose_constellation(payload))


if __name__ == "__main__":  # pragma: no cover - CLI helper
    main()
