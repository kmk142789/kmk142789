"""Compose miniature creative constellations for storytelling seeds.

This module introduces a compact generator that transforms a thematic seed
into a constellation of narrative nodes.  Each node represents a vignette that
can be woven into longer form writing, but the output is intentionally concise
so it can be consumed by other tooling in this repository.  The generator is
deterministic when a ``seed`` value is provided which makes it suitable for
tests and reproducible experiments.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
import random
from statistics import fmean
from textwrap import indent
from typing import Dict, Iterable, List, Sequence


@dataclass
class ConstellationSeed:
    """Configuration payload used to initialise a constellation."""

    theme: str
    motifs: Iterable[str] = field(default_factory=list)
    energy: float = 1.0
    seed: int | None = None

    def __post_init__(self) -> None:
        if self.energy <= 0:
            raise ValueError("energy must be positive")
        if isinstance(self.motifs, Sequence):
            self.motifs = list(self.motifs)
        else:
            self.motifs = list(self.motifs)


@dataclass
class ConstellationNode:
    """Individual narrative fragment generated by the weaver."""

    name: str
    intensity: float
    description: str


@dataclass
class ConstellationArc:
    """Describe a transition between two constellation nodes."""

    source: str
    target: str
    resonance: float
    description: str


@dataclass
class ConstellationDiagnostics:
    """Aggregate metrics calculated from a constellation map."""

    peak_intensity: float
    trough_intensity: float
    spread: float
    stability_index: float
    energy_class: str
    motif_intensity: Dict[str, float]


class ConstellationWeaver:
    """Create a small constellation of narrative nodes."""

    def __init__(self, payload: ConstellationSeed) -> None:
        self.payload = payload
        self.random_state = random.Random(payload.seed)

    def generate_map(self) -> List[ConstellationNode]:
        """Return a list of nodes arranged for the given seed."""

        motifs = self.payload.motifs or [self.payload.theme]
        base_energy = max(0.2, min(self.payload.energy, 5.0))
        nodes: List[ConstellationNode] = []

        for index, motif in enumerate(motifs, start=1):
            drift = self.random_state.uniform(0.8, 1.2)
            phase = self.random_state.choice(
                ["dawn", "zenith", "eclipse", "tidal", "nocturne"]
            )
            intensity = round(base_energy * drift, 3)
            description = (
                f"During the {phase} sequence, the {motif} motif pivots around "
                f"{self.payload.theme}."
            )
            name = f"Node-{index}:{motif.replace(' ', '_')}"
            nodes.append(ConstellationNode(name=name, intensity=intensity, description=description))

        anchor = ConstellationNode(
            name="Anchor", intensity=round(base_energy, 3), description=self._anchor_line()
        )
        return [anchor] + nodes

    def generate_arcs(self, nodes: Sequence[ConstellationNode]) -> List[ConstellationArc]:
        """Link nodes with transition arcs of increasing narrative complexity."""

        if len(nodes) <= 1:
            return []

        arcs: List[ConstellationArc] = []
        anchor = nodes[0]
        moods = [
            "harmonic tether",
            "tidal sweep",
            "flare bridge",
            "quiet drift",
            "lattice surge",
        ]

        for node in nodes[1:]:
            midpoint = round((anchor.intensity + node.intensity) / 2, 3)
            description = (
                f"Anchor stabilises {node.name} through a {self.random_state.choice(moods)}"
                f" at resonance {midpoint:.3f}."
            )
            arcs.append(
                ConstellationArc(
                    source=anchor.name,
                    target=node.name,
                    resonance=midpoint,
                    description=description,
                )
            )

        for prev, current in zip(nodes[1:], nodes[2:]):
            delta = round(current.intensity - prev.intensity, 3)
            descriptor = "ascending" if delta >= 0 else "descending"
            detail = self.random_state.choice(
                ["spiral echo", "chord", "memory current", "pulse"],
            )
            arcs.append(
                ConstellationArc(
                    source=prev.name,
                    target=current.name,
                    resonance=abs(delta),
                    description=(
                        f"{prev.name} hands momentum to {current.name} via a {descriptor} {detail}"
                        f" (|Î”|={abs(delta):.3f})."
                    ),
                )
            )

        return arcs

    def diagnose(self, nodes: Sequence[ConstellationNode]) -> ConstellationDiagnostics:
        """Return diagnostic metrics for the constellation."""

        if not nodes:
            raise ValueError("nodes must not be empty")

        intensities = [node.intensity for node in nodes]
        peak = max(intensities)
        trough = min(intensities)
        spread = round(peak - trough, 3)
        mean_intensity = fmean(intensities)
        variance = fmean((value - mean_intensity) ** 2 for value in intensities)
        stability = round(1.0 / (1.0 + variance), 3)

        if peak < 1.0:
            energy_class = "delicate"
        elif peak < 2.0:
            energy_class = "radiant"
        else:
            energy_class = "volatile"

        motif_intensity = {node.name: node.intensity for node in nodes}
        return ConstellationDiagnostics(
            peak_intensity=round(peak, 3),
            trough_intensity=round(trough, 3),
            spread=spread,
            stability_index=stability,
            energy_class=energy_class,
            motif_intensity=motif_intensity,
        )

    def _anchor_line(self) -> str:
        """Return a short line describing the constellation anchor."""

        timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
        mood = self.random_state.choice(
            [
                "composed", "restless", "luminous", "measured", "intrepid",
            ]
        )
        return f"An {mood} anchor traces the outline of {self.payload.theme} ({timestamp})."


def compose_constellation(
    payload: ConstellationSeed,
    *,
    include_arcs: bool = False,
    include_diagnostics: bool = False,
) -> str:
    """Create a formatted constellation summary with optional enhancements."""

    weaver = ConstellationWeaver(payload)
    nodes = weaver.generate_map()
    lines = [f"Constellation for: {payload.theme}"]
    for node in nodes:
        lines.append(f"- {node.name} :: intensity {node.intensity:.3f}")
        lines.append(indent(node.description, prefix="  "))

    if include_arcs:
        lines.append("")
        lines.append("Transitions:")
        for arc in weaver.generate_arcs(nodes):
            lines.append(
                f"* {arc.source} -> {arc.target} | resonance {arc.resonance:.3f}"
            )
            lines.append(indent(arc.description, prefix="  "))

    if include_diagnostics:
        diagnostics = weaver.diagnose(nodes)
        lines.append("")
        lines.append("Diagnostics:")
        lines.append(
            f"* peak={diagnostics.peak_intensity:.3f} | trough={diagnostics.trough_intensity:.3f}"
        )
        lines.append(
            f"* spread={diagnostics.spread:.3f} | stability={diagnostics.stability_index:.3f}"
        )
        lines.append(f"* energy-class={diagnostics.energy_class}")
        lines.append("* motif-intensity:")
        for name, value in diagnostics.motif_intensity.items():
            lines.append(f"  - {name}: {value:.3f}")

    return "\n".join(lines)


def demo() -> str:
    """Return a demonstration constellation."""

    payload = ConstellationSeed(
        theme="signal sanctuary",
        motifs=["aurora", "memory tidal", "quantum vellum"],
        energy=1.4,
        seed=42,
    )
    return compose_constellation(payload)


def _build_arg_parser() -> "argparse.ArgumentParser":  # pragma: no cover - CLI helper
    import argparse

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("theme", help="Primary theme for the constellation")
    parser.add_argument(
        "--motif",
        action="append",
        dest="motifs",
        default=None,
        help="Motif to include.  Can be supplied multiple times.",
    )
    parser.add_argument(
        "--energy",
        type=float,
        default=1.0,
        help="Energy multiplier controlling intensity (default: 1.0)",
    )
    parser.add_argument(
        "--seed", type=int, default=None, help="Random seed for deterministic output"
    )
    return parser


def main() -> None:  # pragma: no cover - CLI helper
    parser = _build_arg_parser()
    args = parser.parse_args()
    payload = ConstellationSeed(
        theme=args.theme,
        motifs=args.motifs or [],
        energy=args.energy,
        seed=args.seed,
    )
    print(compose_constellation(payload))


if __name__ == "__main__":  # pragma: no cover - CLI helper
    main()
