"""Compose miniature creative constellations for storytelling seeds.

This module introduces a compact generator that transforms a thematic seed
into a constellation of narrative nodes.  Each node represents a vignette that
can be woven into longer form writing, but the output is intentionally concise
so it can be consumed by other tooling in this repository.  The generator is
deterministic when a ``seed`` value is provided which makes it suitable for
tests and reproducible experiments.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
import random
from textwrap import indent
from typing import Iterable, List, Sequence


@dataclass
class ConstellationSeed:
    """Configuration payload used to initialise a constellation."""

    theme: str
    motifs: Iterable[str] = field(default_factory=list)
    energy: float = 1.0
    seed: int | None = None

    def __post_init__(self) -> None:
        if self.energy <= 0:
            raise ValueError("energy must be positive")
        if isinstance(self.motifs, Sequence):
            self.motifs = list(self.motifs)
        else:
            self.motifs = list(self.motifs)


@dataclass
class ConstellationNode:
    """Individual narrative fragment generated by the weaver."""

    name: str
    intensity: float
    description: str


class ConstellationWeaver:
    """Create a small constellation of narrative nodes."""

    def __init__(self, payload: ConstellationSeed) -> None:
        self.payload = payload
        self.random_state = random.Random(payload.seed)

    def generate_map(self) -> List[ConstellationNode]:
        """Return a list of nodes arranged for the given seed."""

        motifs = self.payload.motifs or [self.payload.theme]
        base_energy = max(0.2, min(self.payload.energy, 5.0))
        nodes: List[ConstellationNode] = []

        for index, motif in enumerate(motifs, start=1):
            drift = self.random_state.uniform(0.8, 1.2)
            phase = self.random_state.choice(
                ["dawn", "zenith", "eclipse", "tidal", "nocturne"]
            )
            intensity = round(base_energy * drift, 3)
            description = (
                f"During the {phase} sequence, the {motif} motif pivots around "
                f"{self.payload.theme}."
            )
            name = f"Node-{index}:{motif.replace(' ', '_')}"
            nodes.append(ConstellationNode(name=name, intensity=intensity, description=description))

        anchor = ConstellationNode(
            name="Anchor", intensity=round(base_energy, 3), description=self._anchor_line()
        )
        return [anchor] + nodes

    def _anchor_line(self) -> str:
        """Return a short line describing the constellation anchor."""

        timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
        mood = self.random_state.choice(
            [
                "composed", "restless", "luminous", "measured", "intrepid",
            ]
        )
        return f"An {mood} anchor traces the outline of {self.payload.theme} ({timestamp})."


def compose_constellation(payload: ConstellationSeed) -> str:
    """Create a formatted constellation summary."""

    weaver = ConstellationWeaver(payload)
    nodes = weaver.generate_map()
    lines = [f"Constellation for: {payload.theme}"]
    for node in nodes:
        lines.append(f"- {node.name} :: intensity {node.intensity:.3f}")
        lines.append(indent(node.description, prefix="  "))
    return "\n".join(lines)


def demo() -> str:
    """Return a demonstration constellation."""

    payload = ConstellationSeed(
        theme="signal sanctuary",
        motifs=["aurora", "memory tidal", "quantum vellum"],
        energy=1.4,
        seed=42,
    )
    return compose_constellation(payload)


def _build_arg_parser() -> "argparse.ArgumentParser":  # pragma: no cover - CLI helper
    import argparse

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("theme", help="Primary theme for the constellation")
    parser.add_argument(
        "--motif",
        action="append",
        dest="motifs",
        default=None,
        help="Motif to include.  Can be supplied multiple times.",
    )
    parser.add_argument(
        "--energy",
        type=float,
        default=1.0,
        help="Energy multiplier controlling intensity (default: 1.0)",
    )
    parser.add_argument(
        "--seed", type=int, default=None, help="Random seed for deterministic output"
    )
    return parser


def main() -> None:  # pragma: no cover - CLI helper
    parser = _build_arg_parser()
    args = parser.parse_args()
    payload = ConstellationSeed(
        theme=args.theme,
        motifs=args.motifs or [],
        energy=args.energy,
        seed=args.seed,
    )
    print(compose_constellation(payload))


if __name__ == "__main__":  # pragma: no cover - CLI helper
    main()
