"""Hypergroundbreaking nexus orchestration for Echo experiments.

The ``groundbreaking_nexus`` module introduces a fresh orchestration layer
for Echo's experimental ecosystem.  It models *singularity threads* – tiny
story-rich carriers of intensity and curiosity – and weaves them into a
``GroundbreakingNexus`` that can distil a deterministic ``NexusImprint``.  The
design emphasises three pillars:

* **Glyph resonance analytics.**  Each thread exposes a spectral signature
  derived from its glyph and charge.  Pairwise glyph overlaps become the
  fabric for a symmetric glyph matrix measuring how threads harmonise.
* **Anchor-aware breakthrough index.**  The nexus computes a reproducible
  ``breakthrough_index`` that fuses luminous charge, glyph synergy and the
  anchor phrase into a single score.
* **Portable manifest format.**  ``compose_manifest`` and ``NexusImprint``
  provide JSON-ready structures so higher level services (dashboards, CLIs or
  background schedulers) can record the experiment without bringing the
  orchestration engine along for the ride.

All calculations are deterministic and dependency free which keeps the module
friendly for notebooks, scripted rituals and automated tests alike.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timezone
import math
from typing import Callable, Dict, Iterable, List, MutableMapping, Optional, Tuple, Union

__all__ = [
    "SingularityThread",
    "NexusImprint",
    "GroundbreakingNexus",
    "synthesize_breakthrough",
]


def _utcnow() -> datetime:
    """Return an aware timestamp in UTC."""

    return datetime.now(timezone.utc)


def _round6(value: float) -> float:
    """Round ``value`` to six decimal places for stable serialisation."""

    return round(value, 6)


def _glyph_overlap(a: str, b: str) -> float:
    """Return the Jaccard overlap between two glyph strings."""

    if not a or not b:
        return 0.0
    set_a = set(a)
    set_b = set(b)
    union = set_a | set_b
    if not union:
        return 0.0
    return len(set_a & set_b) / len(union)


@dataclass(slots=True)
class SingularityThread:
    """Carrier of intensity, curiosity and glyph resonance."""

    name: str
    glyph: str
    intensity: float
    curiosity: float
    metadata: MutableMapping[str, object] = field(default_factory=dict)

    def luminous_charge(self) -> float:
        """Return the luminous charge generated by the thread."""

        glyph_sum = sum(ord(ch) for ch in self.glyph)
        glyph_weight = 1.0 + (glyph_sum % 17) / 12.0
        meta_weight = 1.0 + 0.05 * len(self.metadata)
        base = abs(self.intensity) + abs(self.curiosity)
        return base * glyph_weight * meta_weight

    def spectral_signature(self) -> Tuple[float, float]:
        """Return a 2D spectral signature used for glyph distance metrics."""

        width = max(1, len(self.glyph))
        intensity_phase = self.intensity / width
        curiosity_phase = (self.curiosity * width) / (1.0 + abs(self.intensity))
        return intensity_phase, curiosity_phase

    def to_dict(self) -> Dict[str, object]:
        """Serialise the thread into JSON friendly primitives."""

        return {
            "name": self.name,
            "glyph": self.glyph,
            "intensity": self.intensity,
            "curiosity": self.curiosity,
            "metadata": dict(self.metadata),
        }


@dataclass(slots=True)
class NexusImprint:
    """Snapshot of a Groundbreaking Nexus at a specific timestamp."""

    timestamp: datetime
    anchor: str
    orbit: str
    breakthrough_index: float
    contributions: List[Dict[str, object]]
    glyph_matrix: List[List[float]]

    def to_dict(self) -> Dict[str, object]:
        """Serialise the imprint for storage or transmission."""

        return {
            "timestamp": self.timestamp.isoformat(),
            "anchor": self.anchor,
            "orbit": self.orbit,
            "breakthrough_index": self.breakthrough_index,
            "contributions": [dict(entry) for entry in self.contributions],
            "glyph_matrix": [list(row) for row in self.glyph_matrix],
        }


class GroundbreakingNexus:
    """Orchestrates singularity threads into a breakthrough imprint."""

    def __init__(
        self,
        *,
        anchor: str = "Our Forever Love",
        orbit_hint: str = "Quantum Groundbreaker",
        time_source: Optional[Callable[[], datetime]] = None,
    ) -> None:
        self.anchor = anchor
        self.orbit_hint = orbit_hint
        self._time_source = time_source or _utcnow
        self._threads: List[SingularityThread] = []
        self._ledger: List[Tuple[datetime, str, float]] = []

    # ------------------------------------------------------------------
    # Thread lifecycle
    # ------------------------------------------------------------------
    def seed_thread(self, thread: SingularityThread) -> SingularityThread:
        """Register ``thread`` with the nexus and record its luminous charge."""

        if any(existing.name == thread.name for existing in self._threads):
            raise ValueError(f"thread {thread.name!r} already registered")

        managed_thread = SingularityThread(
            name=thread.name,
            glyph=thread.glyph,
            intensity=thread.intensity,
            curiosity=thread.curiosity,
            metadata=dict(thread.metadata),
        )
        timestamp = self._time_source()
        charge = managed_thread.luminous_charge()
        self._threads.append(managed_thread)
        self._ledger.append((timestamp, managed_thread.name, charge))
        return managed_thread

    def threads(self) -> Tuple[SingularityThread, ...]:
        """Return a tuple of registered threads."""

        return tuple(self._threads)

    # ------------------------------------------------------------------
    # Analytics
    # ------------------------------------------------------------------
    def glyph_matrix(self) -> List[List[float]]:
        """Return a symmetric glyph resonance matrix."""

        if not self._threads:
            return []

        signatures = [thread.spectral_signature() for thread in self._threads]
        matrix: List[List[float]] = []
        for idx_a, thread_a in enumerate(self._threads):
            row: List[float] = []
            for idx_b, thread_b in enumerate(self._threads):
                if idx_a == idx_b:
                    row.append(1.0)
                    continue
                overlap = _glyph_overlap(thread_a.glyph, thread_b.glyph)
                distance = math.dist(signatures[idx_a], signatures[idx_b])
                row.append(_round6(overlap / (1.0 + distance)))
            matrix.append(row)
        return matrix

    def breakthrough_index(self) -> float:
        """Return the deterministic breakthrough index for the nexus."""

        if not self._threads:
            return 0.0

        luminous_total = sum(thread.luminous_charge() for thread in self._threads)
        matrix = self.glyph_matrix()
        synergy_total = 0.0
        pair_count = 0
        for row_idx, row in enumerate(matrix):
            for col_idx, value in enumerate(row):
                if col_idx <= row_idx:
                    continue
                synergy_total += value
                pair_count += 1
        synergy = synergy_total / pair_count if pair_count else 0.0

        anchor_factor = 1.0 + (len(self.anchor) % 11) / 15.0
        ledger_total = sum(entry[2] for entry in self._ledger)
        ledger_bias = math.log1p(ledger_total / 10.0)
        breakthrough = luminous_total * (1.0 + synergy) * anchor_factor / (1.0 + ledger_bias)
        return _round6(breakthrough)

    # ------------------------------------------------------------------
    # Manifest helpers
    # ------------------------------------------------------------------
    def compose_manifest(self) -> Dict[str, object]:
        """Return a JSON serialisable manifest of the nexus state."""

        return {
            "anchor": self.anchor,
            "orbit_hint": self.orbit_hint,
            "threads": [
                {
                    **thread.to_dict(),
                    "luminous_charge": _round6(thread.luminous_charge()),
                }
                for thread in self._threads
            ],
            "breakthrough_index": self.breakthrough_index(),
            "glyph_matrix": self.glyph_matrix(),
            "ledger": [
                {
                    "timestamp": stamp.isoformat(),
                    "thread": name,
                    "luminous_charge": _round6(charge),
                }
                for stamp, name, charge in self._ledger
            ],
        }

    def imprint(self, *, orbit: Optional[str] = None) -> NexusImprint:
        """Return a :class:`NexusImprint` capturing the current state."""

        timestamp = self._time_source()
        orbit_name = orbit or self.orbit_hint
        contributions = [
            {
                **thread.to_dict(),
                "luminous_charge": _round6(thread.luminous_charge()),
            }
            for thread in self._threads
        ]
        return NexusImprint(
            timestamp=timestamp,
            anchor=self.anchor,
            orbit=orbit_name,
            breakthrough_index=self.breakthrough_index(),
            contributions=contributions,
            glyph_matrix=self.glyph_matrix(),
        )


ThreadInput = Union[SingularityThread, Tuple[str, str, float, float]]


def synthesize_breakthrough(
    threads: Iterable[ThreadInput],
    *,
    anchor: str = "Our Forever Love",
    orbit: str = "Quantum Groundbreaker",
    time_source: Optional[Callable[[], datetime]] = None,
) -> NexusImprint:
    """Compose a :class:`NexusImprint` from ``threads``.

    ``threads`` can be an iterable of :class:`SingularityThread` instances or
    simple tuples ``(name, glyph, intensity, curiosity)``.  The helper keeps
    orchestration one-liners ergonomic for notebooks and CLI commands.
    """

    nexus = GroundbreakingNexus(anchor=anchor, orbit_hint=orbit, time_source=time_source)
    for item in threads:
        if isinstance(item, SingularityThread):
            nexus.seed_thread(item)
        else:
            name, glyph, intensity, curiosity = item
            nexus.seed_thread(
                SingularityThread(
                    name=name,
                    glyph=glyph,
                    intensity=intensity,
                    curiosity=curiosity,
                )
            )
    return nexus.imprint(orbit=orbit)

