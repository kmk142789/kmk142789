"""Continuum resonance subsystem for the Echo Genesis Core.

The :class:`GenesisResonanceLayer` couples the structural scans generated by
:class:`~echo.continuum_resonance_field.ContinuumResonanceField` with
Genesis orchestration.  It computes a compact payload that can be consumed by
:class:`~echo.echo_genesis_core.EchoGenesisCore` as a probe, exposing how
balanced the repository lanes are, which areas need attention, and whether
pulse cadence remains stable.
"""
from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING, Any, Mapping, Sequence

from .continuum_resonance_field import (
    ContinuumResonanceField,
    ContinuumResonanceReport,
    LaneResonance,
)

if TYPE_CHECKING:
    from .privacy.zk_layer import ZeroKnowledgePrivacyLayer


@dataclass(slots=True)
class LaneFocus:
    """Serializable focus summary for a lane."""

    lane: str
    resonance: float
    activity_ratio: float
    doc_ratio: float
    code_ratio: float
    freshness_days: float | None

    def to_dict(self) -> Mapping[str, Any]:
        return {
            "lane": self.lane,
            "resonance": round(self.resonance, 6),
            "activity_ratio": round(self.activity_ratio, 6),
            "doc_ratio": round(self.doc_ratio, 6),
            "code_ratio": round(self.code_ratio, 6),
            "freshness_days": self.freshness_days,
        }


class GenesisResonanceLayer:
    """High-level Continuum subsystem plugged into the Genesis Core."""

    def __init__(
        self,
        field: ContinuumResonanceField,
        *,
        focus_lanes: int = 3,
        privacy_layer: "ZeroKnowledgePrivacyLayer" | None = None,
    ) -> None:
        self._field = field
        self._focus_lanes = max(1, int(focus_lanes))
        self._latest: Mapping[str, Any] | None = None
        self._privacy_layer = privacy_layer

    @property
    def field(self) -> ContinuumResonanceField:
        """Return the wrapped :class:`ContinuumResonanceField`."""

        return self._field

    def snapshot(self) -> Mapping[str, Any]:
        """Return a structured payload for the Genesis Core probe."""

        report = self._field.scan()
        payload = self._compose_payload(report)
        self._latest = payload
        return payload

    def latest(self) -> Mapping[str, Any]:
        """Return the cached payload, if a scan has already happened."""

        return dict(self._latest or {})

    # ------------------------------------------------------------------
    # Payload helpers
    # ------------------------------------------------------------------
    def _compose_payload(self, report: ContinuumResonanceReport) -> Mapping[str, Any]:
        focus = [
            LaneFocus(
                lane=lane.lane,
                resonance=lane.resonance_index,
                activity_ratio=lane.activity_ratio,
                doc_ratio=lane.doc_ratio,
                code_ratio=lane.code_ratio,
                freshness_days=lane.freshness_days,
            ).to_dict()
            for lane in report.lanes[: self._focus_lanes]
        ]
        gaps = self._lane_gap(report.lanes)
        signal = self._signal(report)
        recommendations = self._recommendations(report, gaps)
        privacy_summary = self._privacy_summary()
        return {
            "generated_at": report.generated_at.isoformat(),
            "root": str(report.root),
            "signal": signal,
            "synchrony_index": round(report.synchrony_index, 6),
            "pulse_stability": round(report.pulse_drift.stability_index, 6),
            "total_pulse_events": report.pulse_drift.total_events,
            "lane_focus": focus,
            "lane_gap": gaps,
            "storylines": list(report.storylines),
            "recommendations": recommendations,
            "privacy": privacy_summary,
        }

    def _signal(self, report: ContinuumResonanceReport) -> float:
        base = report.synchrony_index * 0.7
        stability = report.pulse_drift.stability_index * 0.3
        combined = max(0.0, min(1.0, base + stability))
        if self._privacy_layer:
            combined = min(1.0, combined + self._privacy_layer.privacy_signal() * 0.05)
        return round(combined, 4)

    def _lane_gap(self, lanes: Sequence[LaneResonance]) -> Mapping[str, Any]:
        if not lanes:
            return {"spread": 0.0, "leaders": [], "lagging": None}
        leaders = self._leaders(lanes)
        lagging = min(lanes, key=lambda lane: lane.resonance_index)
        spread = round(leaders[0].resonance_index - lagging.resonance_index, 6)
        return {
            "spread": spread,
            "leaders": [lane.lane for lane in leaders],
            "lagging": {
                "lane": lagging.lane,
                "resonance": round(lagging.resonance_index, 6),
                "freshness_days": lagging.freshness_days,
            },
        }

    def _leaders(self, lanes: Sequence[LaneResonance]) -> Sequence[LaneResonance]:
        if not lanes:
            return ()
        best = max(lanes, key=lambda lane: lane.resonance_index)
        return [lane for lane in lanes if lane.resonance_index == best.resonance_index]

    def _recommendations(
        self,
        report: ContinuumResonanceReport,
        gaps: Mapping[str, Any],
    ) -> list[str]:
        recs: list[str] = []
        spread = float(gaps.get("spread", 0.0))
        lagging = gaps.get("lagging")
        if spread > 0.25 and isinstance(lagging, Mapping):
            recs.append(f"balance activity around {lagging['lane']}")
        if report.pulse_drift.stability_index < 0.5:
            recs.append("stabilize pulse cadence")
        if self._privacy_layer and self._privacy_layer.privacy_signal() < 0.25:
            recs.append("request privacy-preserving proofs")
        if not recs:
            recs.append("sustain resonance field alignment")
        if report.storylines:
            recs.append(f"amplify storyline: {report.storylines[0]}")
        return recs

    def _privacy_summary(self) -> Mapping[str, Any] | None:
        if not self._privacy_layer:
            return None
        return {
            "signal": self._privacy_layer.privacy_signal(),
            "commitments": self._privacy_layer.recent_commitments(limit=5),
        }


__all__ = ["GenesisResonanceLayer", "LaneFocus"]
