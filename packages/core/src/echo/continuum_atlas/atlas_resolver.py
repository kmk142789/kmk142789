"""Continuum Atlas ledger resolution helpers.

The resolver ingests matches from the KeyHunter service as well as oracle
payloads parsed by :mod:`echo.continuum_compass`.  The helpers return an
:class:`AtlasState` instance that contains the consolidated ledger for wallets,
domains, and applications.  Any claim that cannot be resolved is pushed onto a
pending queue so that human operators can review the outstanding assets.

The resulting state can be exported as a lightweight attestation document that
is signed with a deterministic digest.  The attestation includes a human
readable summary generated by :func:`echo.continuum_compass.parse_compass_payload`
so downstream tooling can render the oracle view alongside the canonical ledger.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from hashlib import sha256
import json
from typing import Any, Iterable, Mapping

from ..continuum_compass import parse_compass_payload

__all__ = [
    "AtlasState",
    "export_attestation",
    "resolve_apps",
    "resolve_domains",
    "resolve_keys",
]


LedgerType = dict[str, dict[str, dict[str, Any]]]
PendingQueue = list[dict[str, Any]]


@dataclass(slots=True)
class AtlasState:
    """Container for the Continuum Atlas canonical ledger."""

    ledger: LedgerType = field(
        default_factory=lambda: {"wallets": {}, "domains": {}, "apps": {}}
    )
    pending: PendingQueue = field(default_factory=list)

    def snapshot(self) -> dict[str, Any]:
        """Return a deep copy of the ledger and pending queue."""

        ledger_copy: LedgerType = {}
        for asset_type, assets in self.ledger.items():
            ledger_section: dict[str, dict[str, Any]] = {}
            for identifier, entry in assets.items():
                entry_copy: dict[str, Any] = {}
                for key, value in entry.items():
                    if isinstance(value, list):
                        entry_copy[key] = list(value)
                    elif isinstance(value, dict):
                        entry_copy[key] = value.copy()
                    else:
                        entry_copy[key] = value
                ledger_section[identifier] = entry_copy
            ledger_copy[asset_type] = ledger_section
        pending_copy = [item.copy() for item in self.pending]
        return {"ledger": ledger_copy, "pending": pending_copy}


def _normalise_owner(value: Any) -> str:
    if value is None:
        return ""
    return str(value).strip()


def _normalise_identifier(*values: Any) -> str:
    for value in values:
        if value:
            identifier = str(value).strip()
            if identifier:
                return identifier
    return ""


def _record_asset(
    state: AtlasState,
    asset_type: str,
    identifier: str,
    owner: str,
    *,
    proof: Any | None = None,
    metadata: Mapping[str, Any] | None = None,
    confidence: Any | None = None,
    source: str | None = None,
) -> None:
    ledger_section = state.ledger.setdefault(asset_type, {})
    entry = ledger_section.setdefault(
        identifier,
        {
            "owner": owner,
            "proofs": [],
            "metadata": {},
        },
    )

    entry["owner"] = owner
    proofs = entry.setdefault("proofs", [])
    if proof:
        proof_str = str(proof)
        if proof_str not in proofs:
            proofs.append(proof_str)
    if metadata:
        entry.setdefault("metadata", {})
        entry["metadata"].update({k: v for k, v in metadata.items() if v is not None})
    if confidence is not None:
        try:
            entry["confidence"] = float(confidence)
        except (TypeError, ValueError):  # pragma: no cover - defensive branch
            pass
    if source:
        entry["source"] = source


def _queue_pending(
    state: AtlasState,
    *,
    asset_type: str,
    identifier: str,
    claim: Mapping[str, Any],
    reason: str,
    source: str,
) -> None:
    state.pending.append(
        {
            "type": asset_type,
            "identifier": identifier,
            "reason": reason,
            "source": source,
            "claim": dict(claim),
        }
    )


def resolve_keys(
    key_matches: Iterable[Mapping[str, Any]],
    *,
    state: AtlasState | None = None,
    source: str = "keyhunter",
) -> AtlasState:
    """Ingest KeyHunter matches into the atlas ledger."""

    atlas = state or AtlasState()
    for match in key_matches:
        owner = _normalise_owner(match.get("owner"))
        identifier = _normalise_identifier(
            match.get("wallet"),
            match.get("address"),
            match.get("id"),
        )
        if owner and identifier:
            _record_asset(
                atlas,
                "wallets",
                identifier,
                owner,
                proof=match.get("proof") or match.get("signature"),
                metadata={"labels": match.get("labels"), "network": match.get("network")},
                confidence=match.get("confidence") or match.get("score"),
                source=match.get("source", source),
            )
        else:
            reason = "missing owner" if not owner else "missing identifier"
            _queue_pending(
                atlas,
                asset_type="wallet",
                identifier=identifier or match.get("wallet", ""),
                claim=match,
                reason=reason,
                source=match.get("source", source),
            )
    return atlas


def resolve_domains(
    domain_claims: Iterable[Mapping[str, Any]],
    *,
    state: AtlasState | None = None,
    source: str = "compass",
) -> AtlasState:
    """Resolve domain ownership claims into the ledger."""

    atlas = state or AtlasState()
    for claim in domain_claims:
        owner = _normalise_owner(claim.get("owner"))
        identifier = _normalise_identifier(
            claim.get("domain"),
            claim.get("hostname"),
        ).lower()
        if owner and identifier:
            _record_asset(
                atlas,
                "domains",
                identifier,
                owner,
                proof=claim.get("proof") or claim.get("dns_proof"),
                metadata={
                    "status": claim.get("status"),
                    "records": claim.get("records"),
                },
                confidence=claim.get("confidence"),
                source=claim.get("source", source),
            )
        else:
            reason = "missing owner" if not owner else "missing identifier"
            _queue_pending(
                atlas,
                asset_type="domain",
                identifier=identifier or claim.get("domain", ""),
                claim=claim,
                reason=reason,
                source=claim.get("source", source),
            )
    return atlas


def resolve_apps(
    app_claims: Iterable[Mapping[str, Any]],
    *,
    state: AtlasState | None = None,
    source: str = "compass",
) -> AtlasState:
    """Resolve application ownership declarations into the ledger."""

    atlas = state or AtlasState()
    for claim in app_claims:
        owner = _normalise_owner(claim.get("owner"))
        identifier = _normalise_identifier(
            claim.get("app"),
            claim.get("app_id"),
            claim.get("slug"),
        ).lower()
        if owner and identifier:
            _record_asset(
                atlas,
                "apps",
                identifier,
                owner,
                proof=claim.get("proof") or claim.get("manifest_signature"),
                metadata={
                    "platform": claim.get("platform"),
                    "version": claim.get("version"),
                },
                confidence=claim.get("confidence"),
                source=claim.get("source", source),
            )
        else:
            reason = "missing owner" if not owner else "missing identifier"
            _queue_pending(
                atlas,
                asset_type="app",
                identifier=identifier or claim.get("app", ""),
                claim=claim,
                reason=reason,
                source=claim.get("source", source),
            )
    return atlas


def export_attestation(
    state: AtlasState,
    oracle_payload: Mapping[str, Any],
    *,
    signer: str = "continuum-atlas",
) -> dict[str, Any]:
    """Return a signed attestation document for the provided *state*."""

    snapshot = state.snapshot()
    report = parse_compass_payload(oracle_payload)
    summary_lines = list(report.render_summary_lines())
    issued_at = report.generated_at or oracle_payload.get("generated_at") or ""

    canonical_payload = {
        "$schema": "https://schemas.echo.xyz/continuum-atlas-attestation.json",
        "signer": signer,
        "issued_at": issued_at,
        "compass_summary": summary_lines,
        "ledger": snapshot["ledger"],
        "pending": snapshot["pending"],
    }

    serialized = json.dumps(canonical_payload, sort_keys=True, separators=(",", ":"))
    signature = sha256(f"{signer}:{serialized}".encode("utf-8")).hexdigest()
    canonical_payload["signature"] = signature
    return canonical_payload
