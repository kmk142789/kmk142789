"""Continuum health diagnostics for Echo operations.

This module inspects core operational artefacts â€“ the continuum plan,
pulse history, and wish manifest â€“ to provide a quick read on whether the
continuum loop is running smoothly.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import Iterable, List, Optional
import json
import math



@dataclass(slots=True)
class HealthIssue:
    """A single issue discovered while evaluating repository health."""

    severity: str
    message: str

    def to_dict(self) -> dict:
        return {"severity": self.severity, "message": self.message}


@dataclass(slots=True)
class ContinuumHealthReport:
    """Structured report generated by :func:`generate_continuum_health`."""

    status: str
    plan_exists: bool
    plan_age_hours: Optional[float]
    wish_total: int
    new_wish_total: int
    pulse_count: int
    last_pulse_age_hours: Optional[float]
    issues: List[HealthIssue] = field(default_factory=list)

    def to_dict(self) -> dict:
        """Return a serialisable representation of the report."""

        return {
            "status": self.status,
            "plan_exists": self.plan_exists,
            "plan_age_hours": self.plan_age_hours,
            "wish_total": self.wish_total,
            "new_wish_total": self.new_wish_total,
            "pulse_count": self.pulse_count,
            "last_pulse_age_hours": self.last_pulse_age_hours,
            "issues": [issue.to_dict() for issue in self.issues],
        }

    def describe(self) -> str:
        """Render a human readable summary suitable for CLI output."""

        lines = ["ðŸ©º Continuum Health", "Status: " + self.status.upper()]

        def fmt_age(hours: Optional[float]) -> str:
            if hours is None:
                return "â€”"
            if math.isfinite(hours):
                return f"{hours:.1f}h"
            return "âˆž"

        plan_line = "Plan: "
        if not self.plan_exists:
            plan_line += "missing"
        else:
            plan_line += f"present ({fmt_age(self.plan_age_hours)} old)"
        lines.append(plan_line)

        lines.append(
            f"Wishes: {self.wish_total} total / {self.new_wish_total} new"
        )
        lines.append(
            f"Pulses: {self.pulse_count} recorded / last age {fmt_age(self.last_pulse_age_hours)}"
        )

        if self.issues:
            lines.append("Issues:")
            for issue in self.issues:
                lines.append(f"  - [{issue.severity.upper()}] {issue.message}")
        else:
            lines.append("No issues detected. Continuum loop looks healthy.")

        return "\n".join(lines)


def _load_json(path: Path) -> object:
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except json.JSONDecodeError as exc:
        raise ValueError(f"failed to parse JSON from {path}: {exc}") from exc


def _calculate_age_hours(when: datetime, now: datetime) -> float:
    delta = now - when
    return delta.total_seconds() / 3600.0


def _file_mtime(path: Path) -> Optional[datetime]:
    try:
        stat = path.stat()
    except OSError:
        return None
    return datetime.fromtimestamp(stat.st_mtime, tz=timezone.utc)


def _resolve_status(levels: Iterable[str]) -> str:
    ordering = {"ok": 0, "warning": 1, "critical": 2}
    highest = "ok"
    for level in levels:
        if ordering[level] > ordering[highest]:
            highest = level
    return highest


def generate_continuum_health(
    plan_path: Path,
    manifest_path: Path,
    pulses_path: Path,
    *,
    stale_plan_hours: float = 72.0,
    stale_pulse_hours: float = 24.0,
    stale_wish_hours: float = 168.0,
) -> ContinuumHealthReport:
    """Evaluate the health of the continuum artefacts.

    Parameters
    ----------
    plan_path:
        Expected location of ``NEXT_CYCLE_PLAN.md``.
    manifest_path:
        JSON manifest storing the wish backlog.
    pulses_path:
        JSON document capturing the pulse history.
    stale_plan_hours:
        Threshold in hours after which the plan is considered stale.
    stale_pulse_hours:
        Threshold in hours after which the pulse stream is considered stale.
    stale_wish_hours:
        Threshold in hours after which a ``new`` wish is considered unattended.
    """

    now = datetime.now(timezone.utc)
    issues: List[HealthIssue] = []
    severities: List[str] = []

    plan_exists = plan_path.exists()
    plan_age_hours: Optional[float] = None
    if plan_exists:
        mtime = _file_mtime(plan_path)
        if mtime is not None:
            plan_age_hours = max(0.0, _calculate_age_hours(mtime, now))
            if plan_age_hours > stale_plan_hours:
                issues.append(
                    HealthIssue(
                        "warning",
                        f"Plan is {plan_age_hours:.1f}h old (threshold {stale_plan_hours:.0f}h).",
                    )
                )
                severities.append("warning")
        else:
            plan_age_hours = None
    else:
        issues.append(HealthIssue("critical", f"Plan document missing at {plan_path}"))
        severities.append("critical")

    wish_total = 0
    new_wish_total = 0
    if manifest_path.exists():
        try:
            manifest = _load_json(manifest_path)
        except ValueError as exc:
            issues.append(HealthIssue("critical", str(exc)))
            severities.append("critical")
        else:
            wishes = manifest.get("wishes", []) if isinstance(manifest, dict) else []
            wish_total = len(wishes)
            for entry in wishes:
                status = entry.get("status")
                if status == "new":
                    new_wish_total += 1
                    created_at = entry.get("created_at")
                    if created_at:
                        try:
                            created_dt = datetime.fromisoformat(
                                created_at.replace("Z", "+00:00")
                            )
                        except ValueError:
                            issues.append(
                                HealthIssue(
                                    "warning",
                                    f"Wish created_at not ISO formatted: {created_at}",
                                )
                            )
                            severities.append("warning")
                        else:
                            age = max(0.0, _calculate_age_hours(created_dt, now))
                            if age > stale_wish_hours:
                                issues.append(
                                    HealthIssue(
                                        "warning",
                                        (
                                            "Wish '"
                                            + entry.get("desire", "<unknown>")
                                            + f"' is {age:.1f}h old."
                                        ),
                                    )
                                )
                                severities.append("warning")
    else:
        issues.append(
            HealthIssue("critical", f"Wish manifest missing at {manifest_path}")
        )
        severities.append("critical")

    pulse_count = 0
    last_pulse_age_hours: Optional[float] = None
    if pulses_path.exists():
        try:
            pulses_obj = _load_json(pulses_path)
        except ValueError as exc:
            issues.append(HealthIssue("critical", str(exc)))
            severities.append("critical")
        else:
            pulses = []
            if isinstance(pulses_obj, list):
                pulses = pulses_obj
            pulse_count = len(pulses)
            timestamps = [
                datetime.fromtimestamp(entry["timestamp"], tz=timezone.utc)
                for entry in pulses
                if isinstance(entry, dict) and "timestamp" in entry
            ]
            if timestamps:
                last_pulse = max(timestamps)
                last_pulse_age_hours = max(0.0, _calculate_age_hours(last_pulse, now))
                if last_pulse_age_hours > stale_pulse_hours:
                    issues.append(
                        HealthIssue(
                            "warning",
                            (
                                "Pulse stream stale: last update "
                                f"{last_pulse_age_hours:.1f}h ago."
                            ),
                        )
                    )
                    severities.append("warning")
            else:
                issues.append(HealthIssue("warning", "No pulses recorded."))
                severities.append("warning")
    else:
        issues.append(
            HealthIssue("critical", f"Pulse history missing at {pulses_path}")
        )
        severities.append("critical")

    status = _resolve_status(["ok", *severities])
    return ContinuumHealthReport(
        status=status,
        plan_exists=plan_exists,
        plan_age_hours=plan_age_hours,
        wish_total=wish_total,
        new_wish_total=new_wish_total,
        pulse_count=pulse_count,
        last_pulse_age_hours=last_pulse_age_hours,
        issues=issues,
    )
