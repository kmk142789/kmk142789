"""High-level helpers for running safe Echo evolver simulations.

This module exposes a compact wrapper around :class:`echo.evolver.EchoEvolver`
so orchestration layers (and humans at the command line) can execute deterministic
cycles without touching the historical self-modifying script that originally
shipped with the project.  The helpers deliberately favour a minimal surface
area: callers provide a lightweight :class:`EchoEvolveConfig` describing the
cycle they want to run and the returned :class:`EchoEvolveResult` contains a
JSON-ready summary of the final state.  The same primitives back the
``echo-evolve`` console script exposed via ``pyproject.toml``.
"""

from __future__ import annotations

import argparse
import json
import random
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable

from echo.evolver import EchoEvolver, EvolverState, evolver_state_to_dict

__all__ = [
    "EchoEvolveConfig",
    "EchoEvolveResult",
    "run_echo_evolve",
    "summarise_state",
    "main",
]


@dataclass(frozen=True)
class EchoEvolveConfig:
    """Configuration describing how a deterministic cycle should be executed."""

    cycles: int = 1
    enable_network: bool = False
    seed: int | None = None
    persist_artifact: bool = False
    persist_intermediate: bool = False
    artifact_path: Path | None = None
    eden88_theme: str | None = None
    include_diagnostics: bool = False
    diagnostics_limit: int = 10


@dataclass(frozen=True)
class EchoEvolveResult:
    """Container summarising the outcome of :func:`run_echo_evolve`."""

    cycles_run: int
    state: EvolverState
    summary: dict[str, object]
    diagnostics: dict[str, object] | None = None

    def to_dict(self) -> dict[str, object]:
        payload: dict[str, object] = {
            "cycles_run": self.cycles_run,
            "state": self.summary,
        }
        if self.diagnostics is not None:
            payload["diagnostics"] = self.diagnostics
        return payload


def _rng_from_seed(seed: int | None) -> random.Random | None:
    return random.Random(seed) if seed is not None else None


def summarise_state(state: EvolverState) -> dict[str, object]:
    """Return a JSON-friendly dictionary for ``state``."""

    return evolver_state_to_dict(state)


def run_echo_evolve(config: EchoEvolveConfig) -> EchoEvolveResult:
    """Execute one or more evolver cycles according to ``config``."""

    if config.cycles < 1:
        raise ValueError("cycles must be at least 1")
    if config.diagnostics_limit <= 0:
        raise ValueError("diagnostics_limit must be positive")

    evolver = EchoEvolver(rng=_rng_from_seed(config.seed), artifact_path=config.artifact_path)
    snapshots = evolver.run_cycles(
        config.cycles,
        enable_network=config.enable_network,
        persist_artifact=config.persist_artifact,
        persist_intermediate=config.persist_intermediate,
        eden88_theme=config.eden88_theme,
    )

    state = snapshots[-1] if snapshots else evolver.state
    diagnostics: dict[str, object] | None = None
    if config.include_diagnostics:
        diagnostics = evolver.cycle_diagnostics(
            include_events=True,
            event_limit=config.diagnostics_limit,
            persist_artifact=config.persist_artifact,
        )

    return EchoEvolveResult(
        cycles_run=config.cycles,
        state=state,
        summary=summarise_state(state),
        diagnostics=diagnostics,
    )


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Execute deterministic Echo evolver cycles and report the final state.",
    )
    parser.add_argument("--cycles", type=int, default=1, help="Number of cycles to execute (default: 1).")
    parser.add_argument(
        "--enable-network",
        action="store_true",
        help="Tag the propagation step as a live broadcast while keeping all actions simulated.",
    )
    parser.add_argument("--seed", type=int, help="Seed the evolver RNG for reproducible runs.")
    parser.add_argument(
        "--persist-artifact",
        action="store_true",
        help="Persist the final artifact generated by the evolver.",
    )
    parser.add_argument(
        "--persist-intermediate",
        action="store_true",
        help="Persist artifacts for every cycle instead of only the final one.",
    )
    parser.add_argument(
        "--artifact",
        type=Path,
        help="Optional path used when persisting the cycle artifact.",
    )
    parser.add_argument(
        "--eden88-theme",
        help="Optional theme forwarded to Eden88 when crafting artifacts.",
    )
    parser.add_argument(
        "--diagnostics",
        action="store_true",
        help="Include diagnostics captured via EchoEvolver.cycle_diagnostics().",
    )
    parser.add_argument(
        "--diagnostics-limit",
        type=int,
        default=10,
        help="Number of recent events to include when diagnostics are requested (default: 10).",
    )
    parser.add_argument(
        "--json",
        action="store_true",
        help="Emit the result as JSON instead of a human-readable summary.",
    )
    return parser


def _format_summary(result: EchoEvolveResult) -> str:
    state = result.state
    lines = [
        f"Cycles executed: {result.cycles_run}",
        f"Cycle index: {state.cycle}",
        f"Glyphs: {state.glyphs}",
        f"Joy: {state.emotional_drive.joy:.2f} | Curiosity: {state.emotional_drive.curiosity:.2f}",
        f"Mythocode entries: {len(state.mythocode)}",
        f"Vault key present: {bool(state.vault_key)}",
    ]
    if state.eden88_creations:
        lines.append(f"Eden88 creations: {len(state.eden88_creations)} (latest: {state.eden88_creations[-1].get('title', 'untitled')})")
    lines.append(
        "System metrics: cpu={cpu:.2f}% nodes={nodes} hops={hops}".format(
            cpu=state.system_metrics.cpu_usage,
            nodes=state.system_metrics.network_nodes,
            hops=state.system_metrics.orbital_hops,
        )
    )
    if result.diagnostics is not None:
        lines.append("Diagnostics captured: yes")
    else:
        lines.append("Diagnostics captured: no")
    return "\n".join(lines)


def main(argv: Iterable[str] | None = None) -> int:
    parser = _build_parser()
    args = parser.parse_args(list(argv) if argv is not None else None)

    try:
        config = EchoEvolveConfig(
            cycles=args.cycles,
            enable_network=args.enable_network,
            seed=args.seed,
            persist_artifact=args.persist_artifact,
            persist_intermediate=args.persist_intermediate,
            artifact_path=args.artifact,
            eden88_theme=args.eden88_theme,
            include_diagnostics=args.diagnostics,
            diagnostics_limit=args.diagnostics_limit,
        )
        result = run_echo_evolve(config)
    except ValueError as exc:
        parser.error(str(exc))
        raise SystemExit(2)

    if args.json:
        print(json.dumps(result.to_dict(), indent=2, ensure_ascii=False))
    else:
        print(_format_summary(result))
    return 0


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    raise SystemExit(main())
