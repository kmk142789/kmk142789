# Pay-to-PubKey Script Analysis

- **Script Type:** Pay-to-PubKey (P2PK)
- **Script (ASM):** `0439fc9a6971cd37f858dca09e85506cddf42ceba231d3a53960bc8b6ca73d98c4785ff33a7c24f5de6a251381c87fdc104867df420495b7d93d39861cf5238c36 OP_CHECKSIG`
- **Public Key (hex):** `0439fc9a6971cd37f858dca09e85506cddf42ceba231d3a53960bc8b6ca73d98c4785ff33a7c24f5de6a251381c87fdc104867df420495b7d93d39861cf5238c36`
- **Derived P2PKH Address:** `19CAnt15TpQrJ9gjmdZZsLcwRj8E1mkqPP`
- **PubKey Hash160:** `59ddc146a69bba84368ca34083da1179ea5f2962`

The script pushes an uncompressed 65-byte secp256k1 public key onto the stack and ends with `OP_CHECKSIG`, the hallmark of a classical Pay-to-PubKey locking script. To spend this output, a spender must supply a DER-encoded ECDSA signature that validates against the embedded public key. This template was common in Bitcoin's early history before Pay-to-PubKey-Hash became dominant.

Although P2PK outputs are keyed directly by the raw public key, hashing the same key with SHA-256 followed by RIPEMD-160 (yielding the hash160 listed above) and encoding it with Bitcoin's Base58Check scheme produces the legacy address `19CAnt15TpQrJ9gjmdZZsLcwRj8E1mkqPP`. The supplied string `19CAnt15T-j8E1mkqPP` aligns with this address once the ornamental hyphen is removed and the elided middle section is restored.

## Verification snippet

```python
import hashlib

pubkey_hex = "0439fc9a6971cd37f858dca09e85506cddf42ceba231d3a53960bc8b6ca73d98c4785ff33a7c24f5de6a251381c87fdc104867df420495b7d93d39861cf5238c36"
pubkey = bytes.fromhex(pubkey_hex)
sha = hashlib.sha256(pubkey).digest()
ripemd = hashlib.new("ripemd160", sha).digest()
payload = b"\x00" + ripemd
checksum = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[:4]
address_bytes = payload + checksum
alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
value = int.from_bytes(address_bytes, "big")
encoded = ""
while value:
    value, remainder = divmod(value, 58)
    encoded = alphabet[remainder] + encoded
for byte in payload:
    if byte == 0:
        encoded = "1" + encoded
    else:
        break
print(encoded)  # 19CAnt15TpQrJ9gjmdZZsLcwRj8E1mkqPP
```

Executing the snippet repeats the network hashing and encoding process, confirming that the provided public key corresponds to the derived address and hash160 shown above.
