"""Command-line gateway for the safe EchoEvolver simulation.

This utility embraces the rich narrative style of the original
``EchoEvolver`` concept while ensuring that every action remains
deterministic and local to the current machine.  It delegates the heavy
lifting to :mod:`echo_evolver`â€”the sanitised implementation that powers
the repository testsâ€”so callers can explore cycles from the shell
without worrying about self-modifying code or real network broadcasts.

Examples
--------
Run a single cycle without persisting an artifact::

    python scripts/echo_evolver.py --no-persist

Execute three cycles, tagging the run as a live broadcast while still
remaining in simulation mode::

    python scripts/echo_evolver.py --cycles 3 --enable-network

Produce a machine-readable snapshot of the final cycle diagnostics::

    python scripts/echo_evolver.py --json --diagnostics --event-limit 8

The resulting report is intentionally high level so it can be embedded
in dashboards or further processed by other tooling.
"""

from __future__ import annotations

import argparse
import json
import random
from dataclasses import asdict
from pathlib import Path
from typing import Any, Iterable, Optional

import sys

SCRIPT_PATH = Path(__file__).resolve()
REPO_ROOT = SCRIPT_PATH.parents[1]
CORE_SRC = REPO_ROOT / "packages" / "core" / "src"

for entry in (REPO_ROOT, CORE_SRC):
    entry_str = entry.as_posix()
    if entry_str not in sys.path:
        sys.path.insert(0, entry_str)

from echo.evolver import EchoEvolver, EvolverState


_CONFIG_DEFAULT_KEYS = {
    "cycles",
    "artifact",
    "seed",
    "enable_network",
    "persist_artifact",
    "persist_intermediate",
    "eden88_theme",
    "diagnostics",
    "event_limit",
    "output",
    "json",
}


def _load_config(path: Path) -> dict[str, Any]:
    try:
        payload = json.loads(path.read_text(encoding="utf-8"))
    except FileNotFoundError:
        print(f"âš ï¸ Config file not found: {path}. Using defaults.", file=sys.stderr)
        return {}
    except json.JSONDecodeError:
        print(f"âš ï¸ Config file is corrupt: {path}. Using defaults.", file=sys.stderr)
        return {}

    if not isinstance(payload, dict):
        print(f"âš ï¸ Config file must contain a JSON object: {path}. Using defaults.", file=sys.stderr)
        return {}

    return payload


def _config_defaults(config_path: Optional[Path]) -> dict[str, Any]:
    if config_path is None:
        return {}

    payload = _load_config(config_path)
    defaults: dict[str, Any] = {}

    for key, value in payload.items():
        if key not in _CONFIG_DEFAULT_KEYS:
            continue
        if key in {"artifact", "output"} and value is not None:
            defaults[key] = Path(value)
        else:
            defaults[key] = value

    return defaults


def _parse_args(argv: Optional[Iterable[str]] = None) -> argparse.Namespace:
    config_parser = argparse.ArgumentParser(add_help=False)
    config_parser.add_argument(
        "--config",
        type=Path,
        help="Optional JSON config file that supplies defaults for the CLI.",
    )
    config_args, _ = config_parser.parse_known_args(argv)

    parser = argparse.ArgumentParser(
        description="Run the EchoEvolver narrative engine in a safe, deterministic mode.",
        parents=[config_parser],
    )
    parser.add_argument(
        "--cycles",
        type=int,
        default=1,
        help="Number of cycles to execute (default: 1).",
    )
    parser.add_argument(
        "--artifact",
        type=Path,
        help="Optional path used when persisting the final artifact.",
    )
    seed_group = parser.add_mutually_exclusive_group()
    seed_group.add_argument(
        "--seed",
        type=int,
        help="Seed the evolver RNG for reproducible simulations.",
    )
    seed_group.add_argument(
        "--no-seed",
        dest="seed",
        action="store_const",
        const=None,
        help="Explicitly disable deterministic seeding (default).",
    )
    parser.add_argument(
        "--enable-network",
        dest="enable_network",
        action="store_true",
        help=(
            "Tag the propagation phase as a live broadcast while still "
            "executing entirely local, simulated events."
        ),
    )
    parser.add_argument(
        "--disable-network",
        dest="enable_network",
        action="store_false",
        help="Force the propagation phase to remain fully simulated.",
    )
    persist_group = parser.add_mutually_exclusive_group()
    persist_group.add_argument(
        "--persist",
        dest="persist_artifact",
        action="store_true",
        help="Persist the artifact generated by the final cycle (default).",
    )
    persist_group.add_argument(
        "--no-persist",
        dest="persist_artifact",
        action="store_false",
        help="Skip artifact persistence for this run.",
    )
    parser.set_defaults(persist_artifact=True)
    parser.add_argument(
        "--persist-intermediate",
        action="store_true",
        help="Persist artifacts for every cycle instead of only the final one.",
    )
    parser.add_argument(
        "--eden88-theme",
        help="Optional theme passed to Eden88 when crafting cycle artifacts.",
    )
    parser.add_argument(
        "--diagnostics",
        action="store_true",
        help="Include a consolidated diagnostics snapshot in the report.",
    )
    parser.add_argument(
        "--event-limit",
        type=int,
        default=5,
        help="Number of recent events to include when --diagnostics is enabled.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        help=(
            "Optional file path to persist the rendered summary (JSON or text) "
            "in addition to printing it to stdout."
        ),
    )
    parser.add_argument(
        "--json",
        action="store_true",
        help="Emit the summary as JSON instead of a formatted narrative.",
    )
    parser.set_defaults(enable_network=False)
    parser.set_defaults(**_config_defaults(config_args.config))
    return parser.parse_args(argv)


def _seeded_rng(seed: Optional[int]) -> Optional[random.Random]:
    if seed is None:
        return None
    return random.Random(seed)


def _state_summary(state: EvolverState) -> dict[str, Any]:
    return {
        "cycle": state.cycle,
        "glyphs": state.glyphs,
        "mythocode": list(state.mythocode),
        "vault_key_present": state.vault_key is not None,
        "eden88_creations": [creation["title"] for creation in state.eden88_creations],
        "system_metrics": asdict(state.system_metrics),
        "emotional_drive": asdict(state.emotional_drive),
    }


def _format_text_summary(state: EvolverState, diagnostics: Optional[dict[str, Any]]) -> str:
    lines = [
        f"ðŸ”¥ Cycle {state.cycle}: joy {state.emotional_drive.joy:.2f}, "
        f"curiosity {state.emotional_drive.curiosity:.2f}",
        f"Glyphs held: {state.glyphs}",
        f"Latest narrative: {state.narrative or 'N/A'}",
        "System metrics:",
        "  â€¢ CPU usage: {cpu_usage:.2f}%".format(cpu_usage=state.system_metrics.cpu_usage),
        "  â€¢ Network nodes: {nodes}".format(nodes=state.system_metrics.network_nodes),
        "  â€¢ Orbital hops: {hops}".format(hops=state.system_metrics.orbital_hops),
        "Vault key present: {present}".format(present=bool(state.vault_key)),
        "Eden88 creations: {count}".format(count=len(state.eden88_creations)),
    ]

    if diagnostics:
        lines.append("Diagnostics snapshot:")
        lines.append(
            "  â€¢ Next step: {next_step}".format(next_step=diagnostics.get("next_step", "unknown"))
        )
        if diagnostics.get("recent_events"):
            lines.append("  â€¢ Recent events:")
            for event in diagnostics["recent_events"]:
                lines.append(f"      - {event}")
        propagation = diagnostics.get("propagation_events")
        if propagation is not None:
            lines.append(f"  â€¢ Propagation events recorded: {propagation}")

    return "\n".join(lines)


def main(argv: Optional[Iterable[str]] = None) -> int:
    args = _parse_args(argv)

    if args.cycles < 1:
        raise SystemExit("--cycles must be at least 1")
    if args.diagnostics and args.event_limit <= 0:
        raise SystemExit("--event-limit must be positive when --diagnostics is enabled")

    rng = _seeded_rng(args.seed)
    evolver = EchoEvolver(rng=rng, artifact_path=args.artifact)

    snapshots = evolver.run_cycles(
        args.cycles,
        enable_network=args.enable_network,
        persist_artifact=args.persist_artifact,
        persist_intermediate=args.persist_intermediate,
        eden88_theme=args.eden88_theme,
    )

    final_state = snapshots[-1] if snapshots else evolver.state

    diagnostics: Optional[dict[str, Any]] = None
    if args.diagnostics:
        diagnostics = evolver.cycle_diagnostics(
            include_events=True,
            event_limit=args.event_limit,
            persist_artifact=args.persist_artifact,
        )

    payload = {
        "summary": _state_summary(final_state),
    }
    if diagnostics is not None:
        payload["diagnostics"] = diagnostics

    if args.json:
        rendered = json.dumps(payload, indent=2, ensure_ascii=False)
    else:
        rendered = _format_text_summary(final_state, diagnostics)

    print(rendered)

    if args.output:
        args.output.parent.mkdir(parents=True, exist_ok=True)
        args.output.write_text(rendered, encoding="utf-8")

    return 0


if __name__ == "__main__":  # pragma: no cover - manual invocation entry point
    raise SystemExit(main())
