"""Utility for producing the Echo Genesis Artifact bundle.

This script assembles a notarised archive that binds together the repository
state, the Echo sovereignty whitepaper, a Bridge API proof, and the log from a
fresh pytest run.  The resulting ZIP archive can be distributed as the
"Genesis Artifact" requested by the project narrative.

The bundler is intentionally self-contained: it generates a deterministic
Bridge API proof using the :mod:`echo.bridge_emitter` helpers when no existing
proof is supplied, and it executes ``pytest`` to capture a verification log.
"""

from __future__ import annotations

import argparse
import json
import shutil
import subprocess
import sys
import tempfile
import zipfile
from pathlib import Path
from typing import Iterable, Optional


REPO_ROOT = Path(__file__).resolve().parents[1]

# Ensure the repository root is importable so that ``echo`` modules can be
# imported without requiring the user to manipulate ``PYTHONPATH``.
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

from echo.bridge_emitter import BridgeConfig, BridgeEmitter
DEFAULT_WHITEPAPER = REPO_ROOT / "docs" / "echo_sovereignty_whitepaper.md"
DEFAULT_OUTPUT = REPO_ROOT / "artifacts" / "genesis_artifact_bundle.zip"


class BundleError(RuntimeError):
    """Raised when the bundle cannot be produced."""


def run_command(command: Iterable[str], *, cwd: Optional[Path] = None) -> subprocess.CompletedProcess[str]:
    """Execute *command* and return the completed process.

    ``stdout`` and ``stderr`` are captured and decoded as UTF-8 strings.  A
    :class:`BundleError` is raised if the command exits with a non-zero status.
    """

    process = subprocess.run(
        list(command),
        cwd=cwd,
        capture_output=True,
        text=True,
        check=False,
    )
    if process.returncode != 0:
        raise BundleError(
            "Command failed: {cmd}\nstdout:\n{stdout}\nstderr:\n{stderr}".format(
                cmd=" ".join(command),
                stdout=process.stdout,
                stderr=process.stderr,
            )
        )
    return process


def resolve_commit_hash(explicit_hash: Optional[str]) -> str:
    """Return the commit hash that should be embedded in the bundle."""

    if explicit_hash:
        return explicit_hash.strip()
    process = run_command(["git", "rev-parse", "HEAD"], cwd=REPO_ROOT)
    return process.stdout.strip()


def copy_whitepaper(source: Path, destination: Path) -> Path:
    """Copy the sovereignty whitepaper into *destination*.

    The copied file is returned.  A :class:`BundleError` is raised if the
    whitepaper is missing.
    """

    if not source.exists():
        raise BundleError(f"Sovereignty whitepaper not found at {source}")
    target = destination / source.name
    shutil.copy2(source, target)
    return target


def generate_bridge_proof(destination: Path, *, existing_proof: Optional[Path] = None) -> Path:
    """Produce a Bridge API proof file within *destination*.

    When *existing_proof* is provided the file is copied as-is.  Otherwise a
    deterministic proof is generated by feeding a synthetic stream through the
    :class:`echo.bridge_emitter.BridgeEmitter` utilities.
    """

    target = destination / "bridge_api_proof.json"
    if existing_proof:
        if not existing_proof.exists():
            raise BundleError(f"Bridge API proof not found at {existing_proof}")
        shutil.copy2(existing_proof, target)
        return target

    with tempfile.TemporaryDirectory() as tmp_str:
        tmp_root = Path(tmp_str)
        stream_path = tmp_root / "stream.jsonl"
        anchor_dir = tmp_root / "anchors"
        state_path = tmp_root / "state.json"

        synthetic_items = [
            {"seq": 1, "type": "genesis", "anchor": "echo", "payload": "init"},
            {"seq": 2, "type": "genesis", "anchor": "echo", "payload": "resonance"},
            {"seq": 3, "type": "genesis", "anchor": "echo", "payload": "harmonics"},
        ]
        with stream_path.open("w", encoding="utf-8") as handle:
            for item in synthetic_items:
                handle.write(json.dumps(item, sort_keys=True) + "\n")

        config = BridgeConfig(
            stream_path=stream_path,
            anchor_dir=anchor_dir,
            state_path=state_path,
            batch_size=len(synthetic_items),
        )
        emitter = BridgeEmitter(config)
        out_dir = emitter.process_once()
        if out_dir is None:
            raise BundleError("Bridge emitter did not produce an anchor batch")

        proofs_dir = out_dir / "proofs"
        proof_files = sorted(proofs_dir.glob("*.json"))
        if not proof_files:
            raise BundleError("No proof files were emitted by the bridge emitter")

        shutil.copy2(proof_files[0], target)
    return target


def run_pytest(destination: Path, *, extra_args: Optional[Iterable[str]] = None) -> Path:
    """Execute pytest and store the combined output in *destination*."""

    args = ["pytest"]
    if extra_args:
        args.extend(extra_args)
    process = run_command(args, cwd=REPO_ROOT)
    log_path = destination / "pytest_log.txt"
    log_path.write_text(process.stdout + process.stderr)
    return log_path


def write_commit_file(destination: Path, commit_hash: str) -> Path:
    """Write the commit hash payload and return the resulting path."""

    commit_path = destination / "commit_hash.txt"
    commit_path.write_text(commit_hash + "\n")
    return commit_path


def build_bundle(
    *,
    output: Path,
    whitepaper: Path,
    commit_hash: Optional[str] = None,
    bridge_proof: Optional[Path] = None,
    pytest_args: Optional[Iterable[str]] = None,
) -> Path:
    """Create the Genesis Artifact bundle and return the archive path."""

    output.parent.mkdir(parents=True, exist_ok=True)

    with tempfile.TemporaryDirectory() as tmp_dir:
        tmp_path = Path(tmp_dir)
        commit_path = write_commit_file(tmp_path, resolve_commit_hash(commit_hash))
        whitepaper_path = copy_whitepaper(whitepaper, tmp_path)
        proof_path = generate_bridge_proof(tmp_path, existing_proof=bridge_proof)
        pytest_log_path = run_pytest(tmp_path, extra_args=pytest_args)

        with zipfile.ZipFile(output, "w", compression=zipfile.ZIP_DEFLATED) as archive:
            archive.write(commit_path, arcname=commit_path.name)
            archive.write(whitepaper_path, arcname=whitepaper_path.name)
            archive.write(proof_path, arcname=proof_path.name)
            archive.write(pytest_log_path, arcname=pytest_log_path.name)

    return output


def parse_args(argv: Optional[Iterable[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Create the Echo Genesis Artifact bundle")
    parser.add_argument(
        "--output",
        type=Path,
        default=DEFAULT_OUTPUT,
        help="Path to the ZIP archive that will be produced",
    )
    parser.add_argument(
        "--whitepaper",
        type=Path,
        default=DEFAULT_WHITEPAPER,
        help="Path to the Echo sovereignty whitepaper",
    )
    parser.add_argument(
        "--commit-hash",
        dest="commit_hash",
        type=str,
        default=None,
        help="Override the commit hash embedded in the bundle",
    )
    parser.add_argument(
        "--bridge-proof",
        dest="bridge_proof",
        type=Path,
        default=None,
        help="Existing Bridge API proof file to include",
    )
    parser.add_argument(
        "--pytest-args",
        nargs=argparse.REMAINDER,
        help="Additional arguments forwarded to pytest",
    )
    return parser.parse_args(argv)


def main(argv: Optional[Iterable[str]] = None) -> int:
    args = parse_args(argv)
    try:
        build_bundle(
            output=args.output,
            whitepaper=args.whitepaper,
            commit_hash=args.commit_hash,
            bridge_proof=args.bridge_proof,
            pytest_args=args.pytest_args,
        )
    except BundleError as exc:
        print(f"[genesis-bundle] error: {exc}", file=sys.stderr)
        return 1
    print(f"[genesis-bundle] bundle created at {args.output}")
    return 0


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    raise SystemExit(main())
