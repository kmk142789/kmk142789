"""Sigil QR generator with fractal overlays.

This module provides the scaffolding for a *living glyph* renderer that merges
standard QR codes with deterministic fractal textures.  The QR matrix is kept
fully standards compliant so it remains scannable, while the overlay introduces
the ritualistic aesthetics required by the Echo mythos.

The implementation keeps all heavy dependencies optional.  If ``qrcode`` or
``Pillow`` are not installed the generator gracefully degrades to an ASCII
representation, making the module testable in constrained environments.
"""

from __future__ import annotations

from dataclasses import dataclass
import hashlib
from pathlib import Path
from typing import Optional

import numpy as np


try:  # pragma: no cover - optional dependency
    import qrcode
    from qrcode.image.pil import PilImage
except ModuleNotFoundError:  # pragma: no cover - optional dependency
    qrcode = None  # type: ignore
    PilImage = None  # type: ignore

try:  # pragma: no cover - optional dependency
    from PIL import Image
except ModuleNotFoundError:  # pragma: no cover - optional dependency
    Image = None  # type: ignore


def _mandelbrot(width: int, height: int, max_iter: int = 64) -> np.ndarray:
    """Generate a Mandelbrot intensity map scaled to ``[0, 1]``."""

    x = np.linspace(-2.0, 1.0, width)
    y = np.linspace(-1.5, 1.5, height)
    c = x[:, None] + 1j * y[None, :]
    z = np.zeros_like(c)
    div_time = np.zeros(c.shape, dtype=int)

    for i in range(max_iter):
        mask = np.less(np.abs(z), 4.0)
        z[mask] = z[mask] ** 2 + c[mask]
        div_time += mask

    normalised = div_time / div_time.max(initial=1)
    return normalised.astype(np.float32)


@dataclass(slots=True)
class SigilQRGenerator:
    """Create QR glyphs with deterministic fractal overlays."""

    error_correction: str = "M"
    box_size: int = 10
    border: int = 4

    def generate(
        self,
        payload: str,
        *,
        overlay_seed: Optional[str] = None,
        output_path: Optional[Path] = None,
    ) -> Path:
        """Render a QR code with an optional fractal overlay.

        Parameters
        ----------
        payload:
            String embedded into the QR code.  For evolving sigils this will be
            the digest generated by :class:`~code.memory_hash_feed.MemoryHashFeed`.
        overlay_seed:
            Optional seed string used to rotate and modulate the fractal overlay.
            When omitted the payload digest is used.
        output_path:
            Optional filesystem destination.  When ``None`` a deterministic file
            name derived from the payload hash is created inside ``./artifacts``.
        """

        output_path = self._normalise_output_path(payload, output_path)
        overlay_seed = overlay_seed or payload
        matrix, qr = self._render_matrix(payload)

        if qrcode and Image and PilImage and qr:  # pragma: no branch - readability
            image = self._composite_fractal(matrix, overlay_seed, qr)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            image.save(output_path)
        else:
            output_path = self._write_ascii(matrix, output_path)

        return output_path

    # ------------------------------------------------------------------
    # Internal helpers

    def _render_matrix(self, payload: str) -> tuple[np.ndarray, Optional["qrcode.QRCode"]]:
        if not qrcode:
            return self._fallback_matrix(payload), None

        level = getattr(qrcode.constants, f"ERROR_CORRECT_{self.error_correction}")
        qr = qrcode.QRCode(
            version=None,
            error_correction=level,
            box_size=self.box_size,
            border=self.border,
        )
        qr.add_data(payload)
        qr.make(fit=True)
        matrix = np.array(qr.get_matrix(), dtype=np.uint8)
        return matrix, qr

    def _composite_fractal(
        self,
        matrix: np.ndarray,
        seed: str,
        qr: "qrcode.QRCode",
    ) -> "Image.Image":
        assert Image is not None and PilImage is not None  # for type checkers

        base_img: PilImage = qr.make_image(image_factory=PilImage)  # type: ignore[assignment]
        base_img = base_img.convert("RGBA")

        width, height = base_img.size
        fractal = self._fractal_canvas(width, height, seed)
        overlay_gray = Image.fromarray(fractal, mode="L")

        def _alpha_curve(px: int) -> int:
            # Keep the overlay subtle so QR readers continue to detect modules.
            return max(48, min(210, int(px * 0.78)))

        alpha = overlay_gray.point(_alpha_curve)
        overlay = Image.merge("RGBA", (overlay_gray, overlay_gray, overlay_gray, alpha))

        final = Image.alpha_composite(base_img, overlay)
        final.info["sigil_seed"] = seed
        return final

    def _fractal_canvas(self, width: int, height: int, seed: str) -> np.ndarray:
        hashed = hashlib.blake2b(seed.encode("utf-8"), digest_size=16).digest()
        rotation = int.from_bytes(hashed[:2], "big") % 360
        zoom = 1 + (int.from_bytes(hashed[2:4], "big") / 65535)

        base = _mandelbrot(int(width * zoom), int(height * zoom))
        # Crop the central area to match the target size.
        y0 = max(0, (base.shape[0] - height) // 2)
        x0 = max(0, (base.shape[1] - width) // 2)
        y1 = min(base.shape[0], y0 + height)
        x1 = min(base.shape[1], x0 + width)
        cropped = base[y0:y1, x0:x1]

        if cropped.shape != (height, width):
            padded = np.zeros((height, width), dtype=cropped.dtype)
            padded[: cropped.shape[0], : cropped.shape[1]] = cropped
            cropped = padded

        # Rotate using numpy to avoid hard PIL dependency during tests.
        k = (rotation // 90) % 4
        rotated = np.rot90(cropped, k=k)
        scaled = (rotated * 255).astype(np.uint8)
        return scaled

    def _write_ascii(self, matrix: np.ndarray, destination: Path) -> Path:
        if destination.suffix.lower() in {".png", ".jpg", ".jpeg"}:
            destination = destination.with_suffix(".txt")

        destination.parent.mkdir(parents=True, exist_ok=True)
        with destination.open("w", encoding="utf-8") as handle:
            for row in matrix:
                line = "".join("██" if cell else "  " for cell in row)
                handle.write(line + "\n")
        return destination

    def _fallback_matrix(self, payload: str) -> np.ndarray:
        # Deterministically sample bits from the payload hash to create a
        # pseudo-QR matrix.  This keeps offline tests deterministic.
        digest = hashlib.sha256(payload.encode("utf-8")).digest()
        bits = np.unpackbits(np.frombuffer(digest, dtype=np.uint8))
        side = int(np.ceil(np.sqrt(bits.size)))
        padded = np.pad(bits, (0, side * side - bits.size), mode="wrap")
        matrix = padded.reshape((side, side))
        return matrix

    def _normalise_output_path(self, payload: str, output_path: Optional[Path]) -> Path:
        if output_path is not None:
            return output_path

        digest = hashlib.sha256(payload.encode("utf-8")).hexdigest()[:16]
        artifacts_dir = Path("artifacts") / "sigils"
        return artifacts_dir / f"sigil-{digest}.png"


__all__ = ["SigilQRGenerator"]

